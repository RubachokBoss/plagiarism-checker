
================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\go.mod
================================================================================

module github.com/RubachokBoss/plagiarism-checker/analysis-service

go 1.24.0

require (
	github.com/go-chi/chi/v5 v5.0.10
	github.com/go-chi/cors v1.2.1
	github.com/golang-migrate/migrate/v4 v4.19.1
	github.com/google/uuid v1.6.0
	github.com/lib/pq v1.10.9
	github.com/rabbitmq/amqp091-go v1.8.1
	github.com/rs/zerolog v1.31.0
	github.com/spf13/viper v1.17.0
)

require (
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pelletier/go-toml/v2 v2.1.0 // indirect
	github.com/sagikazarmark/locafero v0.3.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.10.0 // indirect
	github.com/spf13/cast v1.5.1 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\go.sum
================================================================================

cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.44.3/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
cloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=
cloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=
cloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=
cloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=
cloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=
cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
cloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=
cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
cloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=
cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=
cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
cloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=
cloud.google.com/go/storage v1.14.0/go.mod h1:GrKmX003DSIwi9o29oFT7YDnHYwZoctc3fOKtUw0Xmo=
dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/containerd/errdefs v1.0.0 h1:tg5yIfIlQIrxYtu9ajqY42W3lpS19XqdxRQeEwYG8PI=
github.com/containerd/errdefs v1.0.0/go.mod h1:+YBYIdtsnF4Iw6nWZhJcqGSg/dwvV7tyJ/kCkyJ2k+M=
github.com/containerd/errdefs/pkg v0.3.0 h1:9IKJ06FvyNlexW690DXuQNx2KA2cUJXx151Xdx3ZPPE=
github.com/containerd/errdefs/pkg v0.3.0/go.mod h1:NJw6s9HwNuRhnjJhM7pylWwMyAkmCQvQ4GpJHEqRLVk=
github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dhui/dktest v0.4.6 h1:+DPKyScKSEp3VLtbMDHcUq6V5Lm5zfZZVb0Sk7Ahom4=
github.com/dhui/dktest v0.4.6/go.mod h1:JHTSYDtKkvFNFHJKqCzVzqXecyv+tKt8EzceOmQOgbU=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v28.3.3+incompatible h1:Dypm25kh4rmk49v1eiVbsAtpAsYURjYkaKubwuBdxEI=
github.com/docker/docker v28.3.3+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.7/go.mod h1:cwu0lG7PUMfa9snN8LXBig5ynNVH9qI8YYLbd1fK2po=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/frankban/quicktest v1.14.4 h1:g2rn0vABPOOXmZUj+vbmUp0lPoXEMuhTpIluN0XL9UY=
github.com/frankban/quicktest v1.14.4/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.6.0 h1:n+5WquG0fcWoWp6xPWfHdbskMCQaFnG6PfBrh1Ky4HY=
github.com/fsnotify/fsnotify v1.6.0/go.mod h1:sl3t1tCWJFWoRz9R8WJCbQihKKwmorjAbSClcnxKAGw=
github.com/go-chi/chi/v5 v5.0.10 h1:rLz5avzKpjqxrYwXNfmjkrYYXOyLJd37pz53UFHC6vk=
github.com/go-chi/chi/v5 v5.0.10/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=
github.com/go-chi/cors v1.2.1 h1:xEC8UT3Rlp2QuWNEr4Fs/c2EAGVKBwy/1vHx3bppil4=
github.com/go-chi/cors v1.2.1/go.mod h1:sSbTewc+6wYHBBCW7ytsFSn836hqM7JxpglAy2Vzc58=
github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=
github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-migrate/migrate/v4 v4.19.1 h1:OCyb44lFuQfYXYLx1SCxPZQGU7mcaZ7gH9yH4jSFbBA=
github.com/golang-migrate/migrate/v4 v4.19.1/go.mod h1:CTcgfjxhaUtsLipnLoQRWCrjYXycRz/g5+RWDuYgPrE=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
github.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
github.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201218002935-b9804c9f04c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
github.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8/go.mod h1:dvDLG8qkwmyD9a/MJJN3XJcT3xFxOKAvTZGvuZmac9g=
github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
github.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.19 h1:JITubQf0MOLdlGRuRq+jtsDlekdYPia9ZFsB8h/APPA=
github.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/pelletier/go-toml/v2 v2.1.0 h1:FnwAJ4oYMvbT/34k9zzHuZNrhlz48GB3/s6at6/MHO4=
github.com/pelletier/go-toml/v2 v2.1.0/go.mod h1:tJU2Z3ZkXwnxa4DPO899bsyIoywizdUvyaeZurnPPDc=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/sftp v1.13.1/go.mod h1:3HaPG6Dq1ILlpPZRO0HVMrsydcdLt6HRDccSgb87qRg=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/rabbitmq/amqp091-go v1.8.1 h1:RejT1SBUim5doqcL6s7iN6SBmsQqyTgXb1xMlH0h1hA=
github.com/rabbitmq/amqp091-go v1.8.1/go.mod h1:+jPrT9iY2eLjRaMSRHUhc3z14E/l85kv/f+6luSD3pc=
github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=
github.com/rs/zerolog v1.31.0 h1:FcTR3NnLWW+NnTwwhFWiJSZr4ECLpqCm6QsEnyvbV4A=
github.com/rs/zerolog v1.31.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=
github.com/sagikazarmark/locafero v0.3.0 h1:zT7VEGWC2DTflmccN/5T1etyKvxSxpHsjb9cJvm4SvQ=
github.com/sagikazarmark/locafero v0.3.0/go.mod h1:w+v7UsPNFwzF1cHuOajOOzoq4U7v/ig1mpRjqV+Bu1U=
github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=
github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
github.com/spf13/afero v1.10.0 h1:EaGW2JJh15aKOejeuJ+wpFSHnbd7GE6Wvp3TsNhb6LY=
github.com/spf13/afero v1.10.0/go.mod h1:UBogFpq8E9Hx+xc5CNTTEpTnuHVmXDwZcZcE1eb/UhQ=
github.com/spf13/cast v1.5.1 h1:R+kOtfhWQE6TVQzY+4D7wJLBgkdVasCEFxSUBYBYIlA=
github.com/spf13/cast v1.5.1/go.mod h1:b9PdjNptOpzXr7Rq1q9gJML/2cdGQAo69NKzQ10KN48=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.17.0 h1:I5txKw7MJasPL/BrfkbA0Jyo/oELqVmux4pR/UxOMfI=
github.com/spf13/viper v1.17.0/go.mod h1:BmMMMLQXSbcHK6KAOiFLz0l5JHrU89OdIRHvsk0+yVI=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=
github.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=
github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
go.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0 h1:F7Jx+6hwnZ41NSFTO5q4LYDtJRXBf2PD0rNBkeB/lus=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0/go.mod h1:UHB22Z8QsdRDrnAtX4PntOl36ajSxcdUMt1sF7Y6E7Q=
go.opentelemetry.io/otel v1.37.0 h1:9zhNfelUvx0KBfu/gb+ZgeAfAgtWrfHJZcAqFC228wQ=
go.opentelemetry.io/otel v1.37.0/go.mod h1:ehE/umFRLnuLa/vSccNq9oS1ErUlkkK71gMcN34UG8I=
go.opentelemetry.io/otel/metric v1.37.0 h1:mvwbQS5m0tbmqML4NqK+e3aDiO02vsf/WgbsdpcPoZE=
go.opentelemetry.io/otel/metric v1.37.0/go.mod h1:04wGrZurHYKOc+RKeye86GwKiTb9FKm1WHtO+4EVr2E=
go.opentelemetry.io/otel/trace v1.37.0 h1:HLdcFNbRQBE2imdSEgm/kwqmQj1Or1l/7bW6mxVK7z4=
go.opentelemetry.io/otel/trace v1.37.0/go.mod h1:TlgrlQ+PtQO5XFerSPUYG0JSgGyryXewPGyayAWSBS0=
go.uber.org/atomic v1.9.0 h1:ECmE8Bn/WFTYwEW/bpKD3M8VtR/zQVbavAoalC1PYyE=
go.uber.org/atomic v1.9.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=
go.uber.org/goleak v1.2.1 h1:NBol2c7O1ZokfZ0LEU9K6Whx/KnwvepVetCUhtKja4A=
go.uber.org/goleak v1.2.1/go.mod h1:qlT2yGI9QafXHhZZLxlSuNsMw3FFLxBr+tBRlmO1xH4=
go.uber.org/multierr v1.9.0 h1:7fIwc/ZtS0q++VgcfqFDxSBZVv/Xo49/SYnDFupUwlI=
go.uber.org/multierr v1.9.0/go.mod h1:X2jQV1h+kxSjClGpnseKVIxpmcjrj7MNnI0bnlfKTVQ=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
golang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=
golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=
golang.org/x/exp v0.0.0-20230905200255-921286631fa9 h1:GoHiUyI/Tp2nVkLI2mCxVkOjsbSXD66ic0XW0js0R9g=
golang.org/x/exp v0.0.0-20230905200255-921286631fa9/go.mod h1:S2oDrQGGwySpoQPVqRShND87VCbxmc6bL1Yd2oYrm6k=
golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=
golang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210225134936-a50acf3fe073/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.38.0 h1:3yZWxaJjBmCWXqhN1qh02AkOnCQ1poK6oF+a7xWL6Gc=
golang.org/x/sys v0.38.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.31.0 h1:aC8ghyu4JhP8VojJ2lEHBnochRno1sgL6nEi9WGFGMM=
golang.org/x/text v0.31.0/go.mod h1:tKRAlv61yKIjGGHX/4tP1LTbc13YSec1pxVEWXzfoeM=
golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=
golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=
golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210108195828-e2f9c7f1fc8e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=
google.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=
google.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=
google.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=
google.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=
google.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
google.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210108203827-ffc7fda8c3d7/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210226172003-ab064af71705/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
google.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.1/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
google.golang.org/grpc v1.34.0/go.mod h1:WotjhfgOW/POjDeRt8vscBtXq+2VjORFy659qA51WJ8=
google.golang.org/grpc v1.35.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/ini.v1 v1.67.0 h1:Dgnx+6+nfE+IfzjUEISNeydPJh9AXNNsWbGP9KzCsOA=
gopkg.in/ini.v1 v1.67.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\main.go
================================================================================

package main

import (
	"context"
	"flag"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/app"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/config"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/database"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/pkg/logger"
)

func main() {
	// РџР°СЂСЃРёРЅРі Р°СЂРіСѓРјРµРЅС‚РѕРІ РєРѕРјР°РЅРґРЅРѕР№ СЃС‚СЂРѕРєРё
	migrateCmd := flag.NewFlagSet("migrate", flag.ExitOnError)
	migrateDirection := migrateCmd.String("direction", "up", "direction of migration (up/down)")

	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "migrate":
			migrateCmd.Parse(os.Args[2:])
			runMigrations(*migrateDirection)
			return
		case "worker":
			runWorker()
			return
		}
	}

	// РРЅРёС†РёР°Р»РёР·Р°С†РёСЏ Р»РѕРіРіРµСЂР°
	log := logger.New()

	// Р—Р°РіСЂСѓР·РєР° РєРѕРЅС„РёРіСѓСЂР°С†РёРё
	cfg, err := config.Load()
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to load configuration")
	}

	// РРЅРёС†РёР°Р»РёР·Р°С†РёСЏ Р±Р°Р·С‹ РґР°РЅРЅС‹С…
	db, err := database.NewPostgres(cfg.Database)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to connect to database")
	}
	defer db.Close()

	// РџСЂРѕРІРµСЂРєР° СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ Р‘Р”
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		log.Fatal().Err(err).Msg("Failed to ping database")
	}

	log.Info().Msg("Database connection established")

	// РЎРѕР·РґР°РЅРёРµ РїСЂРёР»РѕР¶РµРЅРёСЏ
	application, err := app.New(cfg, log, db)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to create application")
	}

	// РљРѕРЅС‚РµРєСЃС‚ РґР»СЏ graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	// Р—Р°РїСѓСЃРє СЃРµСЂРІРµСЂР° РІ РіРѕСЂСѓС‚РёРЅРµ
	go func() {
		if err := application.Run(); err != nil {
			log.Fatal().Err(err).Msg("Failed to run application")
		}
	}()

	log.Info().Msgf("Analysis Service started on %s", cfg.Server.Address)

	// РћР¶РёРґР°РЅРёРµ СЃРёРіРЅР°Р»Р° Р·Р°РІРµСЂС€РµРЅРёСЏ
	<-ctx.Done()
	log.Info().Msg("Shutting down Analysis Service...")

	// Graceful shutdown
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := application.Shutdown(shutdownCtx); err != nil {
		log.Error().Err(err).Msg("Failed to shutdown gracefully")
	}

	log.Info().Msg("Analysis Service stopped")
}

func runMigrations(direction string) {
	log := logger.New()
	cfg, err := config.Load()
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to load configuration")
	}

	migrator := database.NewMigrator(cfg.Database)

	switch direction {
	case "up":
		if err := migrator.Up(); err != nil {
			log.Fatal().Err(err).Msg("Failed to apply migrations")
		}
		log.Info().Msg("Migrations applied successfully")
	case "down":
		if err := migrator.Down(); err != nil {
			log.Fatal().Err(err).Msg("Failed to rollback migrations")
		}
		log.Info().Msg("Migrations rolled back successfully")
	default:
		log.Fatal().Msg("Invalid migration direction. Use 'up' or 'down'")
	}
}

func runWorker() {
	log := logger.New()
	cfg, err := config.Load()
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to load configuration")
	}

	log.Info().Msg("Starting standalone worker...")
	// Р—РґРµСЃСЊ РјРѕР¶РЅРѕ Р·Р°РїСѓСЃС‚РёС‚СЊ С‚РѕР»СЊРєРѕ РІРѕСЂРєРµСЂ Р±РµР· HTTP СЃРµСЂРІРµСЂР°
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\config\config.yaml
================================================================================

server:
  address: ":8083"
  read_timeout: 15s
  write_timeout: 15s
  idle_timeout: 60s
  shutdown_timeout: 10s

database:
  host: "postgres-analysis"
  port: 5432
  user: "analysis_user"
  password: "analysis_password"
  name: "analysis_db"
  sslmode: "disable"
  max_open_conns: 25
  max_idle_conns: 5
  conn_max_lifetime: "5m"

services:
  work:
    url: "http://work-service:8081"
    works_endpoint: "/api/v1/works"
    timeout: 10s
    retry_count: 3
    retry_delay: "100ms"

  file:
    url: "http://file-service:8082"
    files_endpoint: "/api/v1/files"
    hash_endpoint: "/api/v1/files/by-hash"
    timeout: 30s
    retry_count: 3
    retry_delay: "100ms"

rabbitmq:
  url: "amqp://guest:guest@rabbitmq:5672/"
  exchange: "plagiarism_exchange"
  routing_key: "work.created"
  queue_name: "work_created_queue"
  consumer_tag: "analysis-consumer"
  prefetch_count: 5

analysis:
  hash_algorithm: "sha256"
  similarity_threshold: 100  # РџСЂРѕС†РµРЅС‚ СЃРѕРІРїР°РґРµРЅРёСЏ РґР»СЏ РїР»Р°РіРёР°С‚Р° (0-100)
  enable_content_analysis: false  # Р‘РѕР»РµРµ РіР»СѓР±РѕРєРёР№ Р°РЅР°Р»РёР· РєРѕРЅС‚РµРЅС‚Р°
  max_workers: 5
  batch_size: 10
  timeout: 300s  # 5 РјРёРЅСѓС‚ РЅР° Р°РЅР°Р»РёР·

logging:
  level: "info"
  pretty: false
  no_color: false

cors:
  allowed_origins:
    - "*"
  allowed_methods:
    - "GET"
    - "POST"
    - "PUT"
    - "DELETE"
    - "OPTIONS"
  allowed_headers:
    - "Accept"
    - "Authorization"
    - "Content-Type"
    - "X-CSRF-Token"
  exposed_headers:
    - "Link"
  allow_credentials: true
  max_age: 300



================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\app\app.go
================================================================================

package app

import (
	"context"
	"database/sql"
	"net/http"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/config"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/database"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/delivery/httpd"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/repository"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/analyzer"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/integration"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/worker"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/worker/queue"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/pkg/logger"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/rs/zerolog"
)

type App struct {
	server         *http.Server
	logger         zerolog.Logger
	config         *config.Config
	db             *sql.DB
	analysisWorker worker.AnalysisWorker
	rabbitMQRepo   repository.RabbitMQRepository
}

func New(cfg *config.Config, log zerolog.Logger, db *sql.DB) (*App, error) {
	// Create RabbitMQ repository
	rabbitMQRepo, err := repository.NewRabbitMQRepository(cfg.RabbitMQ.URL, log)
	if err != nil {
		return nil, err
	}

	// Setup RabbitMQ queue
	if err := rabbitMQRepo.SetupQueue(
		cfg.RabbitMQ.Exchange,
		cfg.RabbitMQ.QueueName,
		cfg.RabbitMQ.RoutingKey,
	); err != nil {
		return nil, err
	}

	// Create RabbitMQ publisher and consumer
	rabbitMQPublisher := queue.NewRabbitMQPublisher(rabbitMQRepo.Channel, log)
	rabbitMQConsumer := queue.NewRabbitMQConsumer(
		rabbitMQRepo.Channel,
		cfg.RabbitMQ.QueueName,
		cfg.RabbitMQ.ConsumerTag,
		log,
	)

	// Create repositories
	reportRepo := repository.NewReportRepository(db, log)
	plagiarismRepo := repository.NewPlagiarismRepository(db, log)

	// Create integration clients
	workClient := integration.NewWorkClient(
		cfg.Services.Work.URL,
		cfg.Services.Work.Timeout,
		cfg.Services.Work.RetryCount,
		cfg.Services.Work.RetryDelay,
		log,
	)

	fileClient := integration.NewFileClient(
		cfg.Services.File.URL,
		cfg.Services.File.Timeout,
		cfg.Services.File.RetryCount,
		cfg.Services.File.RetryDelay,
		log,
	)

	// Create analyzers
	hashComparator := analyzer.NewHashComparator(cfg.Analysis.HashAlgorithm)

	plagiarismChecker := analyzer.NewPlagiarismChecker(
		workClient,
		fileClient,
		hashComparator,
		log,
		analyzer.PlagiarismCheckerConfig{
			HashAlgorithm:       cfg.Analysis.HashAlgorithm,
			SimilarityThreshold: cfg.Analysis.SimilarityThreshold,
			EnableDeepAnalysis:  cfg.Analysis.EnableContentAnalysis,
			Timeout:             cfg.Analysis.Timeout,
			MaxRetries:          cfg.Services.Work.RetryCount,
		},
	)

	// Create message handler
	messageHandler := queue.NewMessageHandler(log)

	// Create services
	analysisService := service.NewAnalysisService(
		reportRepo,
		plagiarismRepo,
		workClient,
		fileClient,
		plagiarismChecker,
		messageHandler,
		rabbitMQPublisher,
		log,
		service.AnalysisConfig{
			HashAlgorithm:       cfg.Analysis.HashAlgorithm,
			SimilarityThreshold: cfg.Analysis.SimilarityThreshold,
			EnableDeepAnalysis:  cfg.Analysis.EnableContentAnalysis,
			Timeout:             cfg.Analysis.Timeout,
			MaxRetries:          cfg.Services.Work.RetryCount,
			BatchSize:           cfg.Analysis.BatchSize,
		},
	)

	reportService := service.NewReportService(
		reportRepo,
		plagiarismRepo,
		log,
	)

	// Create worker pool
	workerPool := worker.NewWorkerPool(cfg.Analysis.MaxWorkers, log)

	// Create analysis worker
	analysisWorker := worker.NewAnalysisWorker(
		workerPool,
		rabbitMQConsumer,
		reportRepo,
		analysisService,
		log,
	)

	// Create HTTP handlers
	handler := httpd.NewHandler(
		analysisService,
		reportService,
		log,
	)

	// Create router
	router := chi.NewRouter()

	// Setup middleware
	router.Use(middleware.RequestID)
	router.Use(middleware.RealIP)
	router.Use(middleware.Logger)
	router.Use(middleware.Recoverer)
	router.Use(middleware.Timeout(60 * time.Second))

	// Setup CORS
	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   cfg.CORS.AllowedOrigins,
		AllowedMethods:   cfg.CORS.AllowedMethods,
		AllowedHeaders:   cfg.CORS.AllowedHeaders,
		ExposedHeaders:   cfg.CORS.ExposedHeaders,
		AllowCredentials: cfg.CORS.AllowCredentials,
		MaxAge:           cfg.CORS.MaxAge,
	}))

	// Register routes
	handler.RegisterRoutes(router)

	// Create HTTP server
	server := &http.Server{
		Addr:         cfg.Server.Address,
		Handler:      router,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
		IdleTimeout:  cfg.Server.IdleTimeout,
	}

	return &App{
		server:         server,
		logger:         log,
		config:         cfg,
		db:             db,
		analysisWorker: analysisWorker,
		rabbitMQRepo:   rabbitMQRepo,
	}, nil
}

func (a *App) Run() error {
	// Start analysis worker
	ctx := context.Background()
	if err := a.analysisWorker.Start(ctx); err != nil {
		a.logger.Error().Err(err).Msg("Failed to start analysis worker")
		return err
	}

	// Start HTTP server
	a.logger.Info().Msgf("Starting analysis service on %s", a.config.Server.Address)
	return a.server.ListenAndServe()
}

func (a *App) Shutdown(ctx context.Context) error {
	a.logger.Info().Msg("Shutting down analysis service...")

	// Stop analysis worker
	if err := a.analysisWorker.Stop(); err != nil {
		a.logger.Error().Err(err).Msg("Failed to stop analysis worker")
	}

	// Close RabbitMQ connection
	if a.rabbitMQRepo != nil {
		if err := a.rabbitMQRepo.Close(); err != nil {
			a.logger.Error().Err(err).Msg("Failed to close RabbitMQ connection")
		}
	}

	// Close database connection
	if a.db != nil {
		if err := a.db.Close(); err != nil {
			a.logger.Error().Err(err).Msg("Failed to close database connection")
		}
	}

	// Shutdown HTTP server
	if err := a.server.Shutdown(ctx); err != nil {
		a.logger.Error().Err(err).Msg("Failed to shutdown HTTP server")
		return err
	}

	a.logger.Info().Msg("Analysis service stopped")
	return nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\config\config.go
================================================================================

package config

import (
	"fmt"
	"time"

	"github.com/spf13/viper"
)

type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	Services ServicesConfig
	RabbitMQ RabbitMQConfig
	Analysis AnalysisConfig
	Logging  LoggingConfig
	CORS     CORSConfig
}

type ServerConfig struct {
	Address         string
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	IdleTimeout     time.Duration
	ShutdownTimeout time.Duration
}

type DatabaseConfig struct {
	Host            string
	Port            int
	User            string
	Password        string
	Name            string
	SSLMode         string
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
}

type ServiceConfig struct {
	URL           string
	WorksEndpoint string
	FilesEndpoint string
	HashEndpoint  string
	Timeout       time.Duration
	RetryCount    int
	RetryDelay    time.Duration
}

type ServicesConfig struct {
	Work ServiceConfig
	File ServiceConfig
}

type RabbitMQConfig struct {
	URL           string
	Exchange      string
	RoutingKey    string
	QueueName     string
	ConsumerTag   string
	PrefetchCount int
}

type AnalysisConfig struct {
	HashAlgorithm         string
	SimilarityThreshold   int
	EnableContentAnalysis bool
	MaxWorkers            int
	BatchSize             int
	Timeout               time.Duration
}

type LoggingConfig struct {
	Level   string
	Pretty  bool
	NoColor bool
}

type CORSConfig struct {
	AllowedOrigins   []string
	AllowedMethods   []string
	AllowedHeaders   []string
	ExposedHeaders   []string
	AllowCredentials bool
	MaxAge           int
}

func Load() (*Config, error) {
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.AddConfigPath("./config")
	viper.AddConfigPath(".")

	// РЈСЃС‚Р°РЅРѕРІРєР° Р·РЅР°С‡РµРЅРёР№ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ
	setDefaults()

	// Р§С‚РµРЅРёРµ РєРѕРЅС„РёРіСѓСЂР°С†РёРё
	if err := viper.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			return nil, fmt.Errorf("failed to read config: %w", err)
		}
	}

	// РџСЂРёРІСЏР·РєР° РїРµСЂРµРјРµРЅРЅС‹С… РѕРєСЂСѓР¶РµРЅРёСЏ
	viper.AutomaticEnv()

	// Р—Р°РіСЂСѓР·РєР° РєРѕРЅС„РёРіСѓСЂР°С†РёРё РІ СЃС‚СЂСѓРєС‚СѓСЂСѓ
	var cfg Config
	if err := viper.Unmarshal(&cfg); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	return &cfg, nil
}

func setDefaults() {
	// Server defaults
	viper.SetDefault("server.address", ":8083")
	viper.SetDefault("server.read_timeout", "15s")
	viper.SetDefault("server.write_timeout", "15s")
	viper.SetDefault("server.idle_timeout", "60s")
	viper.SetDefault("server.shutdown_timeout", "10s")

	// Database defaults
	viper.SetDefault("database.host", "localhost")
	viper.SetDefault("database.port", 5432)
	viper.SetDefault("database.user", "analysis_user")
	viper.SetDefault("database.password", "analysis_password")
	viper.SetDefault("database.name", "analysis_db")
	viper.SetDefault("database.sslmode", "disable")
	viper.SetDefault("database.max_open_conns", 25)
	viper.SetDefault("database.max_idle_conns", 5)
	viper.SetDefault("database.conn_max_lifetime", "5m")

	// Work service defaults
	viper.SetDefault("services.work.url", "http://work-service:8081")
	viper.SetDefault("services.work.works_endpoint", "/api/v1/works")
	viper.SetDefault("services.work.timeout", "10s")
	viper.SetDefault("services.work.retry_count", 3)
	viper.SetDefault("services.work.retry_delay", "100ms")

	// File service defaults
	viper.SetDefault("services.file.url", "http://file-service:8082")
	viper.SetDefault("services.file.files_endpoint", "/api/v1/files")
	viper.SetDefault("services.file.hash_endpoint", "/api/v1/files/by-hash")
	viper.SetDefault("services.file.timeout", "30s")
	viper.SetDefault("services.file.retry_count", 3)
	viper.SetDefault("services.file.retry_delay", "100ms")

	// RabbitMQ defaults
	viper.SetDefault("rabbitmq.url", "amqp://guest:guest@localhost:5672/")
	viper.SetDefault("rabbitmq.exchange", "plagiarism_exchange")
	viper.SetDefault("rabbitmq.routing_key", "work.created")
	viper.SetDefault("rabbitmq.queue_name", "work_created_queue")
	viper.SetDefault("rabbitmq.consumer_tag", "analysis-consumer")
	viper.SetDefault("rabbitmq.prefetch_count", 5)

	// Analysis defaults
	viper.SetDefault("analysis.hash_algorithm", "sha256")
	viper.SetDefault("analysis.similarity_threshold", 100)
	viper.SetDefault("analysis.enable_content_analysis", false)
	viper.SetDefault("analysis.max_workers", 5)
	viper.SetDefault("analysis.batch_size", 10)
	viper.SetDefault("analysis.timeout", "300s")

	// Logging defaults
	viper.SetDefault("logging.level", "info")
	viper.SetDefault("logging.pretty", false)
	viper.SetDefault("logging.no_color", false)

	// CORS defaults
	viper.SetDefault("cors.allowed_origins", []string{"*"})
	viper.SetDefault("cors.allowed_methods", []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"})
	viper.SetDefault("cors.allowed_headers", []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"})
	viper.SetDefault("cors.exposed_headers", []string{"Link"})
	viper.SetDefault("cors.allow_credentials", true)
	viper.SetDefault("cors.max_age", 300)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\database\migrations.go
================================================================================

package database

import (
	"database/sql"
	"fmt"
	"os"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/config"
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

type Migrator struct {
	migrate *migrate.Migrate
}

func NewMigrator(cfg config.DatabaseConfig) *Migrator {
	dsn := fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.Name, cfg.SSLMode,
	)

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		panic(fmt.Sprintf("failed to open database: %v", err))
	}
	defer db.Close()

	driver, err := postgres.WithInstance(db, &postgres.Config{})
	if err != nil {
		panic(fmt.Sprintf("failed to create migration driver: %v", err))
	}

	// РџРѕР»СѓС‡Р°РµРј РїСѓС‚СЊ Рє РјРёРіСЂР°С†РёСЏРј
	migrationPath := "file://migrations"
	if _, err := os.Stat("migrations"); os.IsNotExist(err) {
		// РџСЂРѕР±СѓРµРј РґСЂСѓРіРѕР№ РїСѓС‚СЊ
		migrationPath = "file://./migrations"
	}

	m, err := migrate.NewWithDatabaseInstance(
		migrationPath,
		"postgres", driver,
	)
	if err != nil {
		panic(fmt.Sprintf("failed to create migrator: %v", err))
	}

	return &Migrator{migrate: m}
}

func (m *Migrator) Up() error {
	if err := m.migrate.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to apply migrations: %w", err)
	}
	return nil
}

func (m *Migrator) Down() error {
	if err := m.migrate.Down(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to rollback migrations: %w", err)
	}
	return nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\database\postgres.go
================================================================================

package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/config"
	_ "github.com/lib/pq"
)

func NewPostgres(cfg config.DatabaseConfig) (*sql.DB, error) {
	dsn := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name, cfg.SSLMode,
	)

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// РќР°СЃС‚СЂР°РёРІР°РµРј РїСѓР» СЃРѕРµРґРёРЅРµРЅРёР№
	db.SetMaxOpenConns(cfg.MaxOpenConns)
	db.SetMaxIdleConns(cfg.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime)

	// РџСЂРѕРІРµСЂСЏРµРј СЃРѕРµРґРёРЅРµРЅРёРµ
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\delivery\httpd\analysis_handler.go
================================================================================

package httpd

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/go-chi/chi/v5"
)

func (h *Handler) AnalyzeWork(w http.ResponseWriter, r *http.Request) {
	var req struct {
		WorkID       string `json:"work_id"`
		FileID       string `json:"file_id"`
		AssignmentID string `json:"assignment_id"`
		StudentID    string `json:"student_id"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Validate required fields
	if req.WorkID == "" || req.FileID == "" || req.AssignmentID == "" || req.StudentID == "" {
		writeError(w, http.StatusBadRequest, "All fields (work_id, file_id, assignment_id, student_id) are required")
		return
	}

	ctx := r.Context()
	result, err := h.analysisService.AnalyzeWork(ctx, req.WorkID, req.FileID, req.AssignmentID, req.StudentID)
	if err != nil {
		h.handleAnalysisError(w, err)
		return
	}

	writeSuccess(w, result)
}

func (h *Handler) AnalyzeWorkAsync(w http.ResponseWriter, r *http.Request) {
	var req struct {
		WorkID       string `json:"work_id"`
		FileID       string `json:"file_id"`
		AssignmentID string `json:"assignment_id"`
		StudentID    string `json:"student_id"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Validate required fields
	if req.WorkID == "" || req.FileID == "" || req.AssignmentID == "" || req.StudentID == "" {
		writeError(w, http.StatusBadRequest, "All fields (work_id, file_id, assignment_id, student_id) are required")
		return
	}

	ctx := r.Context()
	reportID, err := h.analysisService.AnalyzeWorkAsync(ctx, req.WorkID, req.FileID, req.AssignmentID, req.StudentID)
	if err != nil {
		h.handleAnalysisError(w, err)
		return
	}

	response := map[string]interface{}{
		"report_id":  reportID,
		"message":    "Analysis started asynchronously",
		"status_url": "/api/v1/analysis/" + req.WorkID,
	}

	writeSuccess(w, response)
}

func (h *Handler) GetAnalysisResult(w http.ResponseWriter, r *http.Request) {
	workID := chi.URLParam(r, "work_id")
	if workID == "" {
		writeError(w, http.StatusBadRequest, "Work ID is required")
		return
	}

	ctx := r.Context()
	result, err := h.analysisService.GetAnalysisResult(ctx, workID)
	if err != nil {
		h.handleAnalysisError(w, err)
		return
	}

	writeSuccess(w, result)
}

func (h *Handler) BatchAnalyze(w http.ResponseWriter, r *http.Request) {
	var req models.BatchAnalysisRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	if len(req.WorkIDs) == 0 {
		writeError(w, http.StatusBadRequest, "At least one work ID is required")
		return
	}

	ctx := r.Context()
	response, err := h.analysisService.BatchAnalyze(ctx, req.WorkIDs)
	if err != nil {
		h.handleAnalysisError(w, err)
		return
	}

	writeSuccess(w, response)
}

func (h *Handler) RetryFailedAnalyses(w http.ResponseWriter, r *http.Request) {
	limit := getIntQueryParam(r, "limit", 10)

	ctx := r.Context()
	retryCount, err := h.analysisService.RetryFailedAnalyses(ctx, limit)
	if err != nil {
		h.handleAnalysisError(w, err)
		return
	}

	response := map[string]interface{}{
		"retried":   retryCount,
		"limit":     limit,
		"message":   "Failed analyses retry completed",
		"timestamp": time.Now().UTC(),
	}

	writeSuccess(w, response)
}

func (h *Handler) handleAnalysisError(w http.ResponseWriter, err error) {
	errMsg := err.Error()

	switch {
	case errMsg == "analysis not found for this work":
		writeError(w, http.StatusNotFound, errMsg)
	case errMsg == "report not found for this work":
		writeError(w, http.StatusNotFound, errMsg)
	case errMsg == "batch size exceeds limit":
		writeError(w, http.StatusBadRequest, errMsg)
	case contains(errMsg, "failed to get file hash"):
		h.logger.Error().Err(err).Msg("File service error")
		writeError(w, http.StatusBadGateway, "File service unavailable")
	case contains(errMsg, "failed to get previous works"):
		h.logger.Error().Err(err).Msg("Work service error")
		writeError(w, http.StatusBadGateway, "Work service unavailable")
	case contains(errMsg, "plagiarism check failed"):
		h.logger.Error().Err(err).Msg("Analysis processing error")
		writeError(w, http.StatusInternalServerError, "Analysis failed")
	default:
		h.logger.Error().Err(err).Msg("Analysis error")
		writeError(w, http.StatusInternalServerError, "Internal server error")
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) && (s[:len(substr)] == substr || contains(s[1:], substr)))
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\delivery\httpd\handler.go
================================================================================

package httpd

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service"
	"github.com/go-chi/chi/v5"
	"github.com/rs/zerolog"
)

type Handler struct {
	analysisService service.AnalysisService
	reportService   service.ReportService
	logger          zerolog.Logger
}

func NewHandler(
	analysisService service.AnalysisService,
	reportService service.ReportService,
	logger zerolog.Logger,
) *Handler {
	return &Handler{
		analysisService: analysisService,
		reportService:   reportService,
		logger:          logger,
	}
}

func (h *Handler) RegisterRoutes(router chi.Router) {
	// Health check
	router.Get("/health", h.HealthCheck)
	router.Get("/status", h.GetServiceStatus)
	router.Get("/stats", h.GetAllStats)

	// Analysis endpoints
	router.Route("/analysis", func(r chi.Router) {
		r.Post("/", h.AnalyzeWork)
		r.Post("/batch", h.BatchAnalyze)
		r.Post("/async", h.AnalyzeWorkAsync)
		r.Get("/{work_id}", h.GetAnalysisResult)
		r.Post("/retry", h.RetryFailedAnalyses)
	})

	// Report endpoints
	router.Route("/reports", func(r chi.Router) {
		r.Get("/", h.SearchReports)
		r.Get("/{report_id}", h.GetReport)
		r.Get("/work/{work_id}", h.GetReportByWorkID)
		r.Get("/assignment/{assignment_id}", h.GetAssignmentStats)
		r.Get("/student/{student_id}", h.GetStudentStats)
		r.Get("/export", h.ExportReports)
	})
}

func (h *Handler) HealthCheck(w http.ResponseWriter, r *http.Request) {
	response := map[string]interface{}{
		"status":    "healthy",
		"service":   "analysis-service",
		"timestamp": time.Now().UTC(),
	}

	writeJSON(w, http.StatusOK, response)
}

// Р’СЃРїРѕРјРѕРіР°С‚РµР»СЊРЅС‹Рµ С„СѓРЅРєС†РёРё
func getIntQueryParam(r *http.Request, key string, defaultValue int) int {
	value := r.URL.Query().Get(key)
	if value == "" {
		return defaultValue
	}

	intValue, err := strconv.Atoi(value)
	if err != nil {
		return defaultValue
	}

	return intValue
}

func getInt64QueryParam(r *http.Request, key string, defaultValue int64) int64 {
	value := r.URL.Query().Get(key)
	if value == "" {
		return defaultValue
	}

	intValue, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return defaultValue
	}

	return intValue
}

func getBoolQueryParam(r *http.Request, key string) *bool {
	value := r.URL.Query().Get(key)
	if value == "" {
		return nil
	}

	boolValue, err := strconv.ParseBool(value)
	if err != nil {
		return nil
	}

	return &boolValue
}

func writeJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	if data != nil {
		json.NewEncoder(w).Encode(data)
	}
}

func writeError(w http.ResponseWriter, status int, message string) {
	writeJSON(w, status, map[string]interface{}{
		"error":   http.StatusText(status),
		"message": message,
	})
}

func writeSuccess(w http.ResponseWriter, data interface{}) {
	response := map[string]interface{}{
		"success": true,
		"data":    data,
	}
	writeJSON(w, http.StatusOK, response)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\delivery\httpd\health_handler.go
================================================================================

package httpd

import (
	"net/http"
	"time"
)

func (h *Handler) HealthCheck(w http.ResponseWriter, r *http.Request) {
	response := map[string]interface{}{
		"status":    "healthy",
		"service":   "analysis-service",
		"timestamp": time.Now().UTC(),
		"version":   "1.0.0",
	}

	writeJSON(w, http.StatusOK, response)
}

func (h *Handler) GetServiceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	status, err := h.analysisService.GetServiceStatus(ctx)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get service status")
		writeError(w, http.StatusInternalServerError, "Failed to get service status")
		return
	}

	writeSuccess(w, status)
}

func (h *Handler) GetAllStats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	stats, err := h.reportService.GetAllStats(ctx)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get all stats")
		writeError(w, http.StatusInternalServerError, "Failed to get statistics")
		return
	}

	writeSuccess(w, stats)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\delivery\httpd\report_handler.go
================================================================================

package httpd

import (
	_ "encoding/json"
	"net/http"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/go-chi/chi/v5"
)

func (h *Handler) GetReport(w http.ResponseWriter, r *http.Request) {
	reportID := chi.URLParam(r, "report_id")
	if reportID == "" {
		writeError(w, http.StatusBadRequest, "Report ID is required")
		return
	}

	ctx := r.Context()
	report, err := h.reportService.GetReport(ctx, reportID)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	writeSuccess(w, report)
}

func (h *Handler) GetReportByWorkID(w http.ResponseWriter, r *http.Request) {
	workID := chi.URLParam(r, "work_id")
	if workID == "" {
		writeError(w, http.StatusBadRequest, "Work ID is required")
		return
	}

	ctx := r.Context()
	report, err := h.reportService.GetReportByWorkID(ctx, workID)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	writeSuccess(w, report)
}

func (h *Handler) SearchReports(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	workID := r.URL.Query().Get("work_id")
	assignmentID := r.URL.Query().Get("assignment_id")
	studentID := r.URL.Query().Get("student_id")
	status := r.URL.Query().Get("status")
	plagiarismFlag := getBoolQueryParam(r, "plagiarism_flag")
	dateFrom := r.URL.Query().Get("date_from")
	dateTo := r.URL.Query().Get("date_to")
	page := getIntQueryParam(r, "page", 1)
	limit := getIntQueryParam(r, "limit", 20)

	// Build request
	req := models.SearchReportsRequest{
		WorkID:         stringOrNil(workID),
		AssignmentID:   stringOrNil(assignmentID),
		StudentID:      stringOrNil(studentID),
		Status:         stringOrNil(status),
		PlagiarismFlag: plagiarismFlag,
		DateFrom:       stringOrNil(dateFrom),
		DateTo:         stringOrNil(dateTo),
		Page:           page,
		Limit:          limit,
	}

	ctx := r.Context()
	response, err := h.reportService.SearchReports(ctx, req)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	writeSuccess(w, response)
}

func (h *Handler) GetAssignmentStats(w http.ResponseWriter, r *http.Request) {
	assignmentID := chi.URLParam(r, "assignment_id")
	if assignmentID == "" {
		writeError(w, http.StatusBadRequest, "Assignment ID is required")
		return
	}

	ctx := r.Context()
	stats, err := h.reportService.GetAssignmentStats(ctx, assignmentID)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	writeSuccess(w, stats)
}

func (h *Handler) GetStudentStats(w http.ResponseWriter, r *http.Request) {
	studentID := chi.URLParam(r, "student_id")
	if studentID == "" {
		writeError(w, http.StatusBadRequest, "Student ID is required")
		return
	}

	ctx := r.Context()
	stats, err := h.reportService.GetStudentStats(ctx, studentID)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	writeSuccess(w, stats)
}

func (h *Handler) GetAllStats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	stats, err := h.reportService.GetAllStats(ctx)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get all stats")
		writeError(w, http.StatusInternalServerError, "Failed to get statistics")
		return
	}

	writeSuccess(w, stats)
}

func (h *Handler) ExportReports(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	format := r.URL.Query().Get("format")
	if format == "" {
		format = "json"
	}

	if format != "json" && format != "csv" {
		writeError(w, http.StatusBadRequest, "Unsupported format. Use 'json' or 'csv'")
		return
	}

	// Build filters
	filters := make(map[string]interface{})

	if workID := r.URL.Query().Get("work_id"); workID != "" {
		filters["work_id"] = workID
	}

	if assignmentID := r.URL.Query().Get("assignment_id"); assignmentID != "" {
		filters["assignment_id"] = assignmentID
	}

	if studentID := r.URL.Query().Get("student_id"); studentID != "" {
		filters["student_id"] = studentID
	}

	if status := r.URL.Query().Get("status"); status != "" {
		filters["status"] = status
	}

	if plagiarismFlag := getBoolQueryParam(r, "plagiarism_flag"); plagiarismFlag != nil {
		filters["plagiarism_flag"] = *plagiarismFlag
	}

	ctx := r.Context()
	data, err := h.reportService.ExportReports(ctx, filters, format)
	if err != nil {
		h.handleReportError(w, err)
		return
	}

	// Set appropriate headers
	w.Header().Set("Content-Type", getContentType(format))
	w.Header().Set("Content-Disposition", "attachment; filename=\"reports."+format+"\"")
	w.WriteHeader(http.StatusOK)
	w.Write(data)
}

func (h *Handler) GetServiceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	status, err := h.analysisService.GetServiceStatus(ctx)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get service status")
		writeError(w, http.StatusInternalServerError, "Failed to get service status")
		return
	}

	writeSuccess(w, status)
}

func (h *Handler) handleReportError(w http.ResponseWriter, err error) {
	errMsg := err.Error()

	switch {
	case errMsg == "report not found":
		writeError(w, http.StatusNotFound, errMsg)
	case errMsg == "assignment not found or no reports available":
		writeError(w, http.StatusNotFound, errMsg)
	case errMsg == "student not found or no reports available":
		writeError(w, http.StatusNotFound, errMsg)
	case contains(errMsg, "failed to search reports"):
		h.logger.Error().Err(err).Msg("Database error")
		writeError(w, http.StatusInternalServerError, "Failed to search reports")
	default:
		h.logger.Error().Err(err).Msg("Report service error")
		writeError(w, http.StatusInternalServerError, "Internal server error")
	}
}

func stringOrNil(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

func getContentType(format string) string {
	switch format {
	case "json":
		return "application/json"
	case "csv":
		return "text/csv"
	default:
		return "application/octet-stream"
	}
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\models\analysis_result.go
================================================================================

package models

import (
	"time"
)

type AnalysisResult struct {
	WorkID            string        `json:"work_id"`
	Status            string        `json:"status"`
	PlagiarismFlag    bool          `json:"plagiarism_flag"`
	OriginalWorkID    *string       `json:"original_work_id,omitempty"`
	MatchPercentage   int           `json:"match_percentage"`
	ComparedWithCount int           `json:"compared_with_count"`
	SimilarWorks      []SimilarWork `json:"similar_works,omitempty"`
	FileHash          string        `json:"file_hash"`
	ProcessingTimeMs  int           `json:"processing_time_ms"`
	AnalyzedAt        time.Time     `json:"analyzed_at"`
}

type SimilarWork struct {
	WorkID          string    `json:"work_id"`
	StudentID       string    `json:"student_id"`
	StudentName     string    `json:"student_name,omitempty"`
	MatchPercentage int       `json:"match_percentage"`
	FileHash        string    `json:"file_hash"`
	SubmittedAt     time.Time `json:"submitted_at"`
}

type PlagiarismCheckRequest struct {
	WorkID       string `json:"work_id"`
	FileID       string `json:"file_id"`
	AssignmentID string `json:"assignment_id"`
	StudentID    string `json:"student_id"`
}

type PlagiarismCheckResponse struct {
	ReportID        string    `json:"report_id"`
	WorkID          string    `json:"work_id"`
	Status          string    `json:"status"`
	PlagiarismFlag  bool      `json:"plagiarism_flag"`
	MatchPercentage int       `json:"match_percentage"`
	OriginalWorkID  *string   `json:"original_work_id,omitempty"`
	AnalyzedAt      time.Time `json:"analyzed_at"`
}

type BatchAnalysisRequest struct {
	WorkIDs []string `json:"work_ids"`
}

type BatchAnalysisResponse struct {
	Total       int                       `json:"total"`
	Processed   int                       `json:"processed"`
	Failed      int                       `json:"failed"`
	Results     []PlagiarismCheckResponse `json:"results"`
	CompletedAt time.Time                 `json:"completed_at"`
}

type AnalysisStats struct {
	TotalReports      int64             `json:"total_reports"`
	CompletedReports  int64             `json:"completed_reports"`
	PendingReports    int64             `json:"pending_reports"`
	PlagiarizedWorks  int64             `json:"plagiarized_works"`
	AvgProcessingTime float64           `json:"avg_processing_time"`
	TopAssignments    []AssignmentStats `json:"top_assignments"`
	TopStudents       []StudentStats    `json:"top_students"`
	RecentActivity    []Report          `json:"recent_activity"`
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\models\dto.go
================================================================================

package models

import "time"

// Data Transfer Objects

type CreateReportRequest struct {
	WorkID       string `json:"work_id" validate:"required"`
	FileID       string `json:"file_id" validate:"required"`
	AssignmentID string `json:"assignment_id" validate:"required"`
	StudentID    string `json:"student_id" validate:"required"`
}

type UpdateReportRequest struct {
	Status          string                 `json:"status" validate:"required,oneof=pending processing completed failed"`
	PlagiarismFlag  bool                   `json:"plagiarism_flag"`
	OriginalWorkID  *string                `json:"original_work_id,omitempty"`
	MatchPercentage int                    `json:"match_percentage" validate:"min=0,max=100"`
	Details         map[string]interface{} `json:"details,omitempty"`
}

type GetReportResponse struct {
	ReportID           string                 `json:"report_id"`
	WorkID             string                 `json:"work_id"`
	FileID             string                 `json:"file_id"`
	AssignmentID       string                 `json:"assignment_id"`
	StudentID          string                 `json:"student_id"`
	Status             string                 `json:"status"`
	PlagiarismFlag     bool                   `json:"plagiarism_flag"`
	OriginalWorkID     *string                `json:"original_work_id,omitempty"`
	MatchPercentage    int                    `json:"match_percentage"`
	FileHash           string                 `json:"file_hash,omitempty"`
	Details            map[string]interface{} `json:"details,omitempty"`
	ProcessingTimeMs   *int                   `json:"processing_time_ms,omitempty"`
	ComparedFilesCount int                    `json:"compared_files_count"`
	CreatedAt          time.Time              `json:"created_at"`
	StartedAt          *time.Time             `json:"started_at,omitempty"`
	CompletedAt        *time.Time             `json:"completed_at,omitempty"`
}

type GetAssignmentStatsResponse struct {
	AssignmentID       string                 `json:"assignment_id"`
	TotalWorks         int                    `json:"total_works"`
	AnalyzedWorks      int                    `json:"analyzed_works"`
	PlagiarizedWorks   int                    `json:"plagiarized_works"`
	AvgMatchPercentage float64                `json:"avg_match_percentage"`
	Reports            []GetReportResponse    `json:"reports,omitempty"`
	Statistics         map[string]interface{} `json:"statistics,omitempty"`
	LastAnalyzedAt     *time.Time             `json:"last_analyzed_at,omitempty"`
}

type GetStudentStatsResponse struct {
	StudentID          string                 `json:"student_id"`
	TotalWorks         int                    `json:"total_works"`
	AnalyzedWorks      int                    `json:"analyzed_works"`
	PlagiarizedWorks   int                    `json:"plagiarized_works"`
	AvgMatchPercentage float64                `json:"avg_match_percentage"`
	Reports            []GetReportResponse    `json:"reports,omitempty"`
	Statistics         map[string]interface{} `json:"statistics,omitempty"`
	LastAnalyzedAt     *time.Time             `json:"last_analyzed_at,omitempty"`
}

type SearchReportsRequest struct {
	WorkID         *string `json:"work_id,omitempty"`
	AssignmentID   *string `json:"assignment_id,omitempty"`
	StudentID      *string `json:"student_id,omitempty"`
	Status         *string `json:"status,omitempty"`
	PlagiarismFlag *bool   `json:"plagiarism_flag,omitempty"`
	DateFrom       *string `json:"date_from,omitempty"`
	DateTo         *string `json:"date_to,omitempty"`
	Page           int     `json:"page" validate:"min=1"`
	Limit          int     `json:"limit" validate:"min=1,max=100"`
}

type SearchReportsResponse struct {
	Reports    []GetReportResponse `json:"reports"`
	Total      int                 `json:"total"`
	Page       int                 `json:"page"`
	Limit      int                 `json:"limit"`
	TotalPages int                 `json:"total_pages"`
}

type HealthCheckResponse struct {
	Status        string    `json:"status"`
	Database      bool      `json:"database"`
	RabbitMQ      bool      `json:"rabbitmq"`
	WorkService   bool      `json:"work_service"`
	FileService   bool      `json:"file_service"`
	ActiveWorkers int       `json:"active_workers"`
	QueueLength   int       `json:"queue_length"`
	Uptime        string    `json:"uptime"`
	Timestamp     time.Time `json:"timestamp"`
}

type FileHashRequest struct {
	FileID string `json:"file_id" validate:"required"`
}

type FileHashResponse struct {
	FileID string `json:"file_id"`
	Hash   string `json:"hash"`
	Size   int64  `json:"size"`
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\models\event.go
================================================================================

package models

import (
	"time"
)

type WorkCreatedEvent struct {
	WorkID       string `json:"work_id"`
	FileID       string `json:"file_id"`
	StudentID    string `json:"student_id"`
	AssignmentID string `json:"assignment_id"`
	Timestamp    int64  `json:"timestamp"`
}

type AnalysisStartedEvent struct {
	WorkID    string    `json:"work_id"`
	StartedAt time.Time `json:"started_at"`
}

type AnalysisCompletedEvent struct {
	WorkID          string    `json:"work_id"`
	ReportID        string    `json:"report_id"`
	Status          string    `json:"status"`
	PlagiarismFlag  bool      `json:"plagiarism_flag"`
	OriginalWorkID  *string   `json:"original_work_id,omitempty"`
	MatchPercentage int       `json:"match_percentage"`
	ProcessingTime  int       `json:"processing_time_ms"`
	CompletedAt     time.Time `json:"completed_at"`
}

type AnalysisFailedEvent struct {
	WorkID   string    `json:"work_id"`
	Error    string    `json:"error"`
	Attempts int       `json:"attempts"`
	FailedAt time.Time `json:"failed_at"`
}

type QueueStatsEvent struct {
	QueueLength    int       `json:"queue_length"`
	ActiveWorkers  int       `json:"active_workers"`
	ProcessedToday int       `json:"processed_today"`
	Timestamp      time.Time `json:"timestamp"`
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\models\report.go
================================================================================

package models

import (
	"encoding/json"
	"time"
)

type Report struct {
	ID                 string          `json:"id" db:"id"`
	WorkID             string          `json:"work_id" db:"work_id"`
	FileID             string          `json:"file_id" db:"file_id"`
	AssignmentID       string          `json:"assignment_id" db:"assignment_id"`
	StudentID          string          `json:"student_id" db:"student_id"`
	Status             string          `json:"status" db:"status"`
	PlagiarismFlag     bool            `json:"plagiarism_flag" db:"plagiarism_flag"`
	OriginalWorkID     *string         `json:"original_work_id,omitempty" db:"original_work_id"`
	MatchPercentage    int             `json:"match_percentage" db:"match_percentage"`
	FileHash           string          `json:"file_hash,omitempty" db:"file_hash"`
	ComparedHashes     []string        `json:"compared_hashes,omitempty" db:"compared_hashes"`
	Details            json.RawMessage `json:"details,omitempty" db:"details"`
	ProcessingTimeMs   *int            `json:"processing_time_ms,omitempty" db:"processing_time_ms"`
	ComparedFilesCount int             `json:"compared_files_count" db:"compared_files_count"`
	CreatedAt          time.Time       `json:"created_at" db:"created_at"`
	StartedAt          *time.Time      `json:"started_at,omitempty" db:"started_at"`
	CompletedAt        *time.Time      `json:"completed_at,omitempty" db:"completed_at"`
	UpdatedAt          time.Time       `json:"updated_at" db:"updated_at"`
}

type ReportStatus string

const (
	ReportStatusPending    ReportStatus = "pending"
	ReportStatusProcessing ReportStatus = "processing"
	ReportStatusCompleted  ReportStatus = "completed"
	ReportStatusFailed     ReportStatus = "failed"
)

func (rs ReportStatus) String() string {
	return string(rs)
}

type ReportDetails struct {
	ComparisonResults []ComparisonResult `json:"comparison_results,omitempty"`
	FileInfo          FileInfo           `json:"file_info,omitempty"`
	AnalysisMetadata  AnalysisMetadata   `json:"analysis_metadata,omitempty"`
}

type ComparisonResult struct {
	ComparedWorkID  string `json:"compared_work_id"`
	StudentID       string `json:"student_id"`
	MatchPercentage int    `json:"match_percentage"`
	FileHash        string `json:"file_hash"`
	FileName        string `json:"file_name"`
	ComparedAt      string `json:"compared_at"`
}

type FileInfo struct {
	FileName     string `json:"file_name"`
	FileSize     int64  `json:"file_size"`
	MimeType     string `json:"mime_type"`
	OriginalName string `json:"original_name"`
}

type AnalysisMetadata struct {
	AlgorithmUsed    string    `json:"algorithm_used"`
	SimilarityMethod string    `json:"similarity_method"`
	AnalysisVersion  string    `json:"analysis_version"`
	Threshold        int       `json:"threshold"`
	StartedAt        time.Time `json:"started_at"`
	CompletedAt      time.Time `json:"completed_at"`
}

type AssignmentStats struct {
	AssignmentID       string     `json:"assignment_id" db:"assignment_id"`
	TotalWorks         int        `json:"total_works" db:"total_works"`
	AnalyzedWorks      int        `json:"analyzed_works" db:"analyzed_works"`
	PlagiarizedWorks   int        `json:"plagiarized_works" db:"plagiarized_works"`
	AvgMatchPercentage float64    `json:"avg_match_percentage" db:"avg_match_percentage"`
	LastAnalyzedAt     *time.Time `json:"last_analyzed_at,omitempty" db:"last_analyzed_at"`
	UpdatedAt          time.Time  `json:"updated_at" db:"updated_at"`
}

type StudentStats struct {
	StudentID          string     `json:"student_id" db:"student_id"`
	TotalWorks         int        `json:"total_works" db:"total_works"`
	AnalyzedWorks      int        `json:"analyzed_works" db:"analyzed_works"`
	PlagiarizedWorks   int        `json:"plagiarized_works" db:"plagiarized_works"`
	AvgMatchPercentage float64    `json:"avg_match_percentage" db:"avg_match_percentage"`
	LastAnalyzedAt     *time.Time `json:"last_analyzed_at,omitempty" db:"last_analyzed_at"`
	UpdatedAt          time.Time  `json:"updated_at" db:"updated_at"`
}

type AnalysisQueueItem struct {
	ID           string     `json:"id" db:"id"`
	WorkID       string     `json:"work_id" db:"work_id"`
	FileID       string     `json:"file_id" db:"file_id"`
	AssignmentID string     `json:"assignment_id" db:"assignment_id"`
	StudentID    string     `json:"student_id" db:"student_id"`
	Status       string     `json:"status" db:"status"`
	Priority     int        `json:"priority" db:"priority"`
	Attempts     int        `json:"attempts" db:"attempts"`
	MaxAttempts  int        `json:"max_attempts" db:"max_attempts"`
	ErrorMessage string     `json:"error_message,omitempty" db:"error_message"`
	CreatedAt    time.Time  `json:"created_at" db:"created_at"`
	ScheduledAt  *time.Time `json:"scheduled_at,omitempty" db:"scheduled_at"`
	StartedAt    *time.Time `json:"started_at,omitempty" db:"started_at"`
	CompletedAt  *time.Time `json:"completed_at,omitempty" db:"completed_at"`
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\repository\plagiarism_repository.go
================================================================================

package repository

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/rs/zerolog"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/lib/pq"
)

type PlagiarismRepository interface {
	FindSimilarWorks(ctx context.Context, fileHash string, assignmentID, excludeWorkID string) ([]models.SimilarWork, error)
	GetWorksByAssignment(ctx context.Context, assignmentID string, excludeWorkID string) ([]models.SimilarWork, error)
	GetFileHashesByAssignment(ctx context.Context, assignmentID string) (map[string]string, error) // file_id -> hash
	SaveComparisonResult(ctx context.Context, workID string, comparedWith []string, results []models.ComparisonResult) error
	GetComparisonHistory(ctx context.Context, workID string) ([]models.ComparisonResult, error)
	GetTopPlagiarizedWorks(ctx context.Context, limit int) ([]models.Report, error)
	GetPlagiarismPatterns(ctx context.Context, assignmentID string) ([]models.ComparisonResult, error)
}

type plagiarismRepository struct {
	*PostgresRepository
}

func NewPlagiarismRepository(db *sql.DB, logger zerolog.Logger) PlagiarismRepository {
	return &plagiarismRepository{
		PostgresRepository: NewPostgresRepository(db, logger),
	}
}

func (r *plagiarismRepository) FindSimilarWorks(ctx context.Context, fileHash string, assignmentID, excludeWorkID string) ([]models.SimilarWork, error) {
	query := `
		SELECT 
			r.work_id,
			r.student_id,
			r.match_percentage,
			r.file_hash,
			r.created_at
		FROM reports r
		WHERE r.assignment_id = $1
			AND r.work_id != $2
			AND r.file_hash = $3
			AND r.status = 'completed'
		ORDER BY r.match_percentage DESC, r.created_at DESC
	`

	rows, err := r.db.QueryContext(ctx, query, assignmentID, excludeWorkID, fileHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var works []models.SimilarWork
	for rows.Next() {
		var work models.SimilarWork
		err := rows.Scan(
			&work.WorkID,
			&work.StudentID,
			&work.MatchPercentage,
			&work.FileHash,
			&work.SubmittedAt,
		)
		if err != nil {
			return nil, err
		}
		works = append(works, work)
	}

	return works, nil
}

func (r *plagiarismRepository) GetWorksByAssignment(ctx context.Context, assignmentID string, excludeWorkID string) ([]models.SimilarWork, error) {
	query := `
		SELECT 
			r.work_id,
			r.student_id,
			r.file_hash,
			r.created_at
		FROM reports r
		WHERE r.assignment_id = $1
			AND r.work_id != $2
			AND r.status = 'completed'
		ORDER BY r.created_at DESC
	`

	rows, err := r.db.QueryContext(ctx, query, assignmentID, excludeWorkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var works []models.SimilarWork
	for rows.Next() {
		var work models.SimilarWork
		err := rows.Scan(
			&work.WorkID,
			&work.StudentID,
			&work.FileHash,
			&work.SubmittedAt,
		)
		if err != nil {
			return nil, err
		}
		works = append(works, work)
	}

	return works, nil
}

func (r *plagiarismRepository) GetFileHashesByAssignment(ctx context.Context, assignmentID string) (map[string]string, error) {
	query := `
		SELECT work_id, file_hash
		FROM reports
		WHERE assignment_id = $1
			AND status = 'completed'
			AND file_hash IS NOT NULL
	`

	rows, err := r.db.QueryContext(ctx, query, assignmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	hashes := make(map[string]string)
	for rows.Next() {
		var workID, fileHash string
		err := rows.Scan(&workID, &fileHash)
		if err != nil {
			return nil, err
		}
		hashes[workID] = fileHash
	}

	return hashes, nil
}

func (r *plagiarismRepository) SaveComparisonResult(ctx context.Context, workID string, comparedWith []string, results []models.ComparisonResult) error {
	// Start transaction
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// Update compared_hashes in reports table
	updateQuery := `
		UPDATE reports
		SET compared_hashes = $1, compared_files_count = $2
		WHERE work_id = $3
	`

	_, err = tx.ExecContext(ctx, updateQuery, pq.Array(comparedWith), len(comparedWith), workID)
	if err != nil {
		return err
	}

	// Save detailed comparison results (if needed)
	// This could be saved in a separate table for detailed analysis
	// For now, we'll just update the reports table

	return tx.Commit()
}

func (r *plagiarismRepository) GetComparisonHistory(ctx context.Context, workID string) ([]models.ComparisonResult, error) {
	query := `
		SELECT 
			details->'comparison_results'
		FROM reports
		WHERE work_id = $1
			AND details IS NOT NULL
	`

	var resultsJSON []byte
	err := r.db.QueryRowContext(ctx, query, workID).Scan(&resultsJSON)
	if err != nil {
		if err == sql.ErrNoRows {
			return []models.ComparisonResult{}, nil
		}
		return nil, err
	}

	// Parse JSON results
	// This is simplified - in real implementation you'd parse the JSON
	// For now, return empty slice
	return []models.ComparisonResult{}, nil
}

func (r *plagiarismRepository) GetTopPlagiarizedWorks(ctx context.Context, limit int) ([]models.Report, error) {
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE plagiarism_flag = TRUE
		ORDER BY match_percentage DESC, created_at DESC
		LIMIT $1
	`

	rows, err := r.db.QueryContext(ctx, query, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, err
		}
		reports = append(reports, *report)
	}

	return reports, nil
}

func (r *plagiarismRepository) GetPlagiarismPatterns(ctx context.Context, assignmentID string) ([]models.ComparisonResult, error) {
	// This would analyze patterns of plagiarism within an assignment
	// For now, return empty results
	return []models.ComparisonResult{}, nil
}

func (r *plagiarismRepository) scanReport(rows *sql.Rows) (*models.Report, error) {
	report := &models.Report{}
	var comparedHashes []sql.NullString
	var originalWorkID sql.NullString
	var processingTimeMs sql.NullInt64

	err := rows.Scan(
		&report.ID,
		&report.WorkID,
		&report.FileID,
		&report.AssignmentID,
		&report.StudentID,
		&report.Status,
		&report.PlagiarismFlag,
		&originalWorkID,
		&report.MatchPercentage,
		&report.FileHash,
		pq.Array(&comparedHashes),
		&report.Details,
		&processingTimeMs,
		&report.ComparedFilesCount,
		&report.CreatedAt,
		&report.StartedAt,
		&report.CompletedAt,
		&report.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	// Convert nullable fields
	if originalWorkID.Valid {
		report.OriginalWorkID = &originalWorkID.String
	}

	if processingTimeMs.Valid {
		timeMs := int(processingTimeMs.Int64)
		report.ProcessingTimeMs = &timeMs
	}

	// Convert compared hashes
	for _, hash := range comparedHashes {
		if hash.Valid {
			report.ComparedHashes = append(report.ComparedHashes, hash.String)
		}
	}

	return report, nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\repository\postgres.go
================================================================================

package repository

import (
	"context"
	"database/sql"
	"time"

	_ "github.com/lib/pq"
	"github.com/rs/zerolog"
)

type PostgresRepository struct {
	db     *sql.DB
	logger zerolog.Logger
}

func NewPostgresRepository(db *sql.DB, logger zerolog.Logger) *PostgresRepository {
	return &PostgresRepository{
		db:     db,
		logger: logger,
	}
}

func (r *PostgresRepository) BeginTx(ctx context.Context) (*sql.Tx, error) {
	return r.db.BeginTx(ctx, nil)
}

func (r *PostgresRepository) Ping(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return r.db.PingContext(ctx)
}

func (r *PostgresRepository) Close() error {
	return r.db.Close()
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\repository\rabbitmq.go
================================================================================

package repository

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/rabbitmq/amqp091-go"
	"github.com/rs/zerolog"
)

type RabbitMQRepository interface {
	Publish(ctx context.Context, exchange, routingKey string, message []byte) error
	Consume(ctx context.Context, queue, consumer string) (<-chan amqp091.Delivery, error)
	SetupQueue(exchange, queue, routingKey string) error
	Close() error
}

type rabbitMQRepository struct {
	conn    *amqp091.Connection
	channel *amqp091.Channel
	logger  zerolog.Logger
}

func NewRabbitMQRepository(url string, logger zerolog.Logger) (RabbitMQRepository, error) {
	conn, err := amqp091.Dial(url)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	channel, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	logger.Info().Msg("Connected to RabbitMQ")

	return &rabbitMQRepository{
		conn:    conn,
		channel: channel,
		logger:  logger,
	}, nil
}

func (r *rabbitMQRepository) Publish(ctx context.Context, exchange, routingKey string, message []byte) error {
	// Set up context with timeout
	publishCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return r.channel.PublishWithContext(
		publishCtx,
		exchange,   // exchange
		routingKey, // routing key
		false,      // mandatory
		false,      // immediate
		amqp091.Publishing{
			ContentType:  "application/json",
			Body:         message,
			DeliveryMode: amqp091.Persistent,
			Timestamp:    time.Now(),
		},
	)
}

func (r *rabbitMQRepository) Consume(ctx context.Context, queue, consumer string) (<-chan amqp091.Delivery, error) {
	// Set prefetch count to control how many messages are consumed at once
	err := r.channel.Qos(
		1,     // prefetch count
		0,     // prefetch size
		false, // global
	)
	if err != nil {
		return nil, fmt.Errorf("failed to set QoS: %w", err)
	}

	msgs, err := r.channel.Consume(
		queue,    // queue
		consumer, // consumer
		false,    // auto-ack
		false,    // exclusive
		false,    // no-local
		false,    // no-wait
		nil,      // args
	)
	if err != nil {
		return nil, fmt.Errorf("failed to register consumer: %w", err)
	}

	return msgs, nil
}

func (r *rabbitMQRepository) SetupQueue(exchange, queue, routingKey string) error {
	// Declare exchange
	err := r.channel.ExchangeDeclare(
		exchange, // name
		"direct", // type
		true,     // durable
		false,    // auto-deleted
		false,    // internal
		false,    // no-wait
		nil,      // arguments
	)
	if err != nil {
		return fmt.Errorf("failed to declare exchange: %w", err)
	}

	// Declare queue
	q, err := r.channel.QueueDeclare(
		queue, // name
		true,  // durable
		false, // delete when unused
		false, // exclusive
		false, // no-wait
		nil,   // arguments
	)
	if err != nil {
		return fmt.Errorf("failed to declare queue: %w", err)
	}

	// Bind queue to exchange
	err = r.channel.QueueBind(
		q.Name,     // queue name
		routingKey, // routing key
		exchange,   // exchange
		false,      // no-wait
		nil,        // arguments
	)
	if err != nil {
		return fmt.Errorf("failed to bind queue: %w", err)
	}

	r.logger.Info().
		Str("exchange", exchange).
		Str("queue", q.Name).
		Str("routing_key", routingKey).
		Msg("RabbitMQ queue setup complete")

	return nil
}

func (r *rabbitMQRepository) Close() error {
	if r.channel != nil {
		if err := r.channel.Close(); err != nil {
			r.logger.Error().Err(err).Msg("Failed to close RabbitMQ channel")
		}
	}

	if r.conn != nil {
		if err := r.conn.Close(); err != nil {
			r.logger.Error().Err(err).Msg("Failed to close RabbitMQ connection")
		}
	}

	return nil
}

// PublishWorkCreated publishes a work created event
func (r *rabbitMQRepository) PublishWorkCreated(ctx context.Context, event interface{}) error {
	message, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	return r.Publish(ctx, "plagiarism_exchange", "work.created", message)
}

// PublishAnalysisCompleted publishes an analysis completed event
func (r *rabbitMQRepository) PublishAnalysisCompleted(ctx context.Context, event interface{}) error {
	message, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	return r.Publish(ctx, "plagiarism_exchange", "analysis.completed", message)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\repository\report_repository.go
================================================================================

package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/rs/zerolog"
	"strings"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/lib/pq"
)

type ReportRepository interface {
	Create(ctx context.Context, report *models.Report) error
	GetByID(ctx context.Context, id string) (*models.Report, error)
	GetByWorkID(ctx context.Context, workID string) (*models.Report, error)
	GetByAssignmentID(ctx context.Context, assignmentID string, limit, offset int) ([]models.Report, int, error)
	GetByStudentID(ctx context.Context, studentID string, limit, offset int) ([]models.Report, int, error)
	GetAll(ctx context.Context, limit, offset int) ([]models.Report, int, error)
	Update(ctx context.Context, report *models.Report) error
	UpdateStatus(ctx context.Context, id, status string) error
	UpdateResult(ctx context.Context, id string, plagiarismFlag bool, originalWorkID *string, matchPercentage int, details []byte) error
	Delete(ctx context.Context, id string) error
	Search(ctx context.Context, filters map[string]interface{}, limit, offset int) ([]models.Report, int, error)
	GetStats(ctx context.Context) (*models.AnalysisStats, error)
	GetAssignmentStats(ctx context.Context, assignmentID string) (*models.AssignmentStats, error)
	GetStudentStats(ctx context.Context, studentID string) (*models.StudentStats, error)
	GetRecentReports(ctx context.Context, limit int) ([]models.Report, error)
	GetReportsByStatus(ctx context.Context, status string, limit int) ([]models.Report, error)
	Exists(ctx context.Context, workID string) (bool, error)
}

type reportRepository struct {
	*PostgresRepository
}

func NewReportRepository(db *sql.DB, logger zerolog.Logger) ReportRepository {
	return &reportRepository{
		PostgresRepository: NewPostgresRepository(db, logger),
	}
}

func (r *reportRepository) Create(ctx context.Context, report *models.Report) error {
	query := `
		INSERT INTO reports (
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
		)
	`

	_, err := r.db.ExecContext(ctx, query,
		report.ID,
		report.WorkID,
		report.FileID,
		report.AssignmentID,
		report.StudentID,
		report.Status,
		report.PlagiarismFlag,
		report.OriginalWorkID,
		report.MatchPercentage,
		report.FileHash,
		pq.Array(report.ComparedHashes),
		report.Details,
		report.ProcessingTimeMs,
		report.ComparedFilesCount,
		report.CreatedAt,
		report.StartedAt,
		report.CompletedAt,
		report.UpdatedAt,
	)

	return err
}

func (r *reportRepository) GetByID(ctx context.Context, id string) (*models.Report, error) {
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE id = $1
	`

	report := &models.Report{}
	var comparedHashes []sql.NullString
	var originalWorkID sql.NullString
	var processingTimeMs sql.NullInt64

	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&report.ID,
		&report.WorkID,
		&report.FileID,
		&report.AssignmentID,
		&report.StudentID,
		&report.Status,
		&report.PlagiarismFlag,
		&originalWorkID,
		&report.MatchPercentage,
		&report.FileHash,
		pq.Array(&comparedHashes),
		&report.Details,
		&processingTimeMs,
		&report.ComparedFilesCount,
		&report.CreatedAt,
		&report.StartedAt,
		&report.CompletedAt,
		&report.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	// Convert nullable fields
	if originalWorkID.Valid {
		report.OriginalWorkID = &originalWorkID.String
	}

	if processingTimeMs.Valid {
		timeMs := int(processingTimeMs.Int64)
		report.ProcessingTimeMs = &timeMs
	}

	// Convert compared hashes
	for _, hash := range comparedHashes {
		if hash.Valid {
			report.ComparedHashes = append(report.ComparedHashes, hash.String)
		}
	}

	return report, nil
}

func (r *reportRepository) GetByWorkID(ctx context.Context, workID string) (*models.Report, error) {
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE work_id = $1
	`

	report := &models.Report{}
	var comparedHashes []sql.NullString
	var originalWorkID sql.NullString
	var processingTimeMs sql.NullInt64

	err := r.db.QueryRowContext(ctx, query, workID).Scan(
		&report.ID,
		&report.WorkID,
		&report.FileID,
		&report.AssignmentID,
		&report.StudentID,
		&report.Status,
		&report.PlagiarismFlag,
		&originalWorkID,
		&report.MatchPercentage,
		&report.FileHash,
		pq.Array(&comparedHashes),
		&report.Details,
		&processingTimeMs,
		&report.ComparedFilesCount,
		&report.CreatedAt,
		&report.StartedAt,
		&report.CompletedAt,
		&report.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	// Convert nullable fields
	if originalWorkID.Valid {
		report.OriginalWorkID = &originalWorkID.String
	}

	if processingTimeMs.Valid {
		timeMs := int(processingTimeMs.Int64)
		report.ProcessingTimeMs = &timeMs
	}

	// Convert compared hashes
	for _, hash := range comparedHashes {
		if hash.Valid {
			report.ComparedHashes = append(report.ComparedHashes, hash.String)
		}
	}

	return report, nil
}

func (r *reportRepository) GetByAssignmentID(ctx context.Context, assignmentID string, limit, offset int) ([]models.Report, int, error) {
	// Get total count
	countQuery := `SELECT COUNT(*) FROM reports WHERE assignment_id = $1`
	var total int
	err := r.db.QueryRowContext(ctx, countQuery, assignmentID).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get reports
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE assignment_id = $1
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3
	`

	rows, err := r.db.QueryContext(ctx, query, assignmentID, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, 0, err
		}
		reports = append(reports, *report)
	}

	return reports, total, nil
}

func (r *reportRepository) GetByStudentID(ctx context.Context, studentID string, limit, offset int) ([]models.Report, int, error) {
	// Get total count
	countQuery := `SELECT COUNT(*) FROM reports WHERE student_id = $1`
	var total int
	err := r.db.QueryRowContext(ctx, countQuery, studentID).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get reports
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE student_id = $1
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3
	`

	rows, err := r.db.QueryContext(ctx, query, studentID, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, 0, err
		}
		reports = append(reports, *report)
	}

	return reports, total, nil
}

func (r *reportRepository) GetAll(ctx context.Context, limit, offset int) ([]models.Report, int, error) {
	// Get total count
	countQuery := `SELECT COUNT(*) FROM reports`
	var total int
	err := r.db.QueryRowContext(ctx, countQuery).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get reports
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		ORDER BY created_at DESC
		LIMIT $1 OFFSET $2
	`

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, 0, err
		}
		reports = append(reports, *report)
	}

	return reports, total, nil
}

func (r *reportRepository) Update(ctx context.Context, report *models.Report) error {
	query := `
		UPDATE reports
		SET 
			status = $1,
			plagiarism_flag = $2,
			original_work_id = $3,
			match_percentage = $4,
			file_hash = $5,
			compared_hashes = $6,
			details = $7,
			processing_time_ms = $8,
			compared_files_count = $9,
			started_at = $10,
			completed_at = $11,
			updated_at = $12
		WHERE id = $13
	`

	_, err := r.db.ExecContext(ctx, query,
		report.Status,
		report.PlagiarismFlag,
		report.OriginalWorkID,
		report.MatchPercentage,
		report.FileHash,
		pq.Array(report.ComparedHashes),
		report.Details,
		report.ProcessingTimeMs,
		report.ComparedFilesCount,
		report.StartedAt,
		report.CompletedAt,
		report.UpdatedAt,
		report.ID,
	)

	return err
}

func (r *reportRepository) UpdateStatus(ctx context.Context, id, status string) error {
	query := `
		UPDATE reports
		SET status = $1, updated_at = $2
		WHERE id = $3
	`

	_, err := r.db.ExecContext(ctx, query, status, time.Now(), id)
	return err
}

func (r *reportRepository) UpdateResult(ctx context.Context, id string, plagiarismFlag bool, originalWorkID *string, matchPercentage int, details []byte) error {
	query := `
		UPDATE reports
		SET 
			plagiarism_flag = $1,
			original_work_id = $2,
			match_percentage = $3,
			details = $4,
			status = 'completed',
			completed_at = $5,
			updated_at = $6
		WHERE id = $7
	`

	_, err := r.db.ExecContext(ctx, query,
		plagiarismFlag,
		originalWorkID,
		matchPercentage,
		details,
		time.Now(),
		time.Now(),
		id,
	)

	return err
}

func (r *reportRepository) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM reports WHERE id = $1`
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *reportRepository) Search(ctx context.Context, filters map[string]interface{}, limit, offset int) ([]models.Report, int, error) {
	// Build WHERE clause
	whereClauses := []string{}
	args := []interface{}{}
	argCount := 1

	for key, value := range filters {
		if value != nil {
			switch key {
			case "work_id", "assignment_id", "student_id", "status":
				whereClauses = append(whereClauses, fmt.Sprintf("%s = $%d", key, argCount))
				args = append(args, value)
				argCount++
			case "plagiarism_flag":
				whereClauses = append(whereClauses, fmt.Sprintf("%s = $%d", key, argCount))
				args = append(args, value)
				argCount++
			case "date_from":
				whereClauses = append(whereClauses, fmt.Sprintf("created_at >= $%d", argCount))
				args = append(args, value)
				argCount++
			case "date_to":
				whereClauses = append(whereClauses, fmt.Sprintf("created_at <= $%d", argCount))
				args = append(args, value)
				argCount++
			}
		}
	}

	// Build query
	whereSQL := ""
	if len(whereClauses) > 0 {
		whereSQL = "WHERE " + strings.Join(whereClauses, " AND ")
	}

	// Get total count
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM reports %s", whereSQL)
	var total int
	err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get reports
	query := fmt.Sprintf(`
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		%s
		ORDER BY created_at DESC
		LIMIT $%d OFFSET $%d
	`, whereSQL, argCount, argCount+1)

	args = append(args, limit, offset)

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, 0, err
		}
		reports = append(reports, *report)
	}

	return reports, total, nil
}

func (r *reportRepository) GetStats(ctx context.Context) (*models.AnalysisStats, error) {
	stats := &models.AnalysisStats{}

	// Basic stats
	query := `
		SELECT 
			COUNT(*) as total_reports,
			COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_reports,
			COUNT(CASE WHEN status IN ('pending', 'processing') THEN 1 END) as pending_reports,
			COUNT(CASE WHEN plagiarism_flag = TRUE THEN 1 END) as plagiarized_works,
			COALESCE(AVG(processing_time_ms), 0) as avg_processing_time
		FROM reports
	`

	err := r.db.QueryRowContext(ctx, query).Scan(
		&stats.TotalReports,
		&stats.CompletedReports,
		&stats.PendingReports,
		&stats.PlagiarizedWorks,
		&stats.AvgProcessingTime,
	)
	if err != nil {
		return nil, err
	}

	// Top assignments
	assignmentQuery := `
		SELECT 
			assignment_id,
			total_works,
			analyzed_works,
			plagiarized_works,
			avg_match_percentage
		FROM assignment_stats
		ORDER BY total_works DESC
		LIMIT 10
	`

	rows, err := r.db.QueryContext(ctx, assignmentQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var stat models.AssignmentStats
		err := rows.Scan(
			&stat.AssignmentID,
			&stat.TotalWorks,
			&stat.AnalyzedWorks,
			&stat.PlagiarizedWorks,
			&stat.AvgMatchPercentage,
		)
		if err != nil {
			return nil, err
		}
		stats.TopAssignments = append(stats.TopAssignments, stat)
	}

	// Top students
	studentQuery := `
		SELECT 
			student_id,
			total_works,
			analyzed_works,
			plagiarized_works,
			avg_match_percentage
		FROM student_stats
		ORDER BY total_works DESC
		LIMIT 10
	`

	rows, err = r.db.QueryContext(ctx, studentQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var stat models.StudentStats
		err := rows.Scan(
			&stat.StudentID,
			&stat.TotalWorks,
			&stat.AnalyzedWorks,
			&stat.PlagiarizedWorks,
			&stat.AvgMatchPercentage,
		)
		if err != nil {
			return nil, err
		}
		stats.TopStudents = append(stats.TopStudents, stat)
	}

	// Recent activity
	recentQuery := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		ORDER BY created_at DESC
		LIMIT 10
	`

	rows, err = r.db.QueryContext(ctx, recentQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, err
		}
		stats.RecentActivity = append(stats.RecentActivity, *report)
	}

	return stats, nil
}

func (r *reportRepository) GetAssignmentStats(ctx context.Context, assignmentID string) (*models.AssignmentStats, error) {
	query := `
		SELECT 
			assignment_id,
			total_works,
			analyzed_works,
			plagiarized_works,
			avg_match_percentage,
			last_analyzed_at,
			updated_at
		FROM assignment_stats
		WHERE assignment_id = $1
	`

	stats := &models.AssignmentStats{}
	err := r.db.QueryRowContext(ctx, query, assignmentID).Scan(
		&stats.AssignmentID,
		&stats.TotalWorks,
		&stats.AnalyzedWorks,
		&stats.PlagiarizedWorks,
		&stats.AvgMatchPercentage,
		&stats.LastAnalyzedAt,
		&stats.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}

	return stats, err
}

func (r *reportRepository) GetStudentStats(ctx context.Context, studentID string) (*models.StudentStats, error) {
	query := `
		SELECT 
			student_id,
			total_works,
			analyzed_works,
			plagiarized_works,
			avg_match_percentage,
			last_analyzed_at,
			updated_at
		FROM student_stats
		WHERE student_id = $1
	`

	stats := &models.StudentStats{}
	err := r.db.QueryRowContext(ctx, query, studentID).Scan(
		&stats.StudentID,
		&stats.TotalWorks,
		&stats.AnalyzedWorks,
		&stats.PlagiarizedWorks,
		&stats.AvgMatchPercentage,
		&stats.LastAnalyzedAt,
		&stats.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}

	return stats, err
}

func (r *reportRepository) GetRecentReports(ctx context.Context, limit int) ([]models.Report, error) {
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		ORDER BY created_at DESC
		LIMIT $1
	`

	rows, err := r.db.QueryContext(ctx, query, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, err
		}
		reports = append(reports, *report)
	}

	return reports, nil
}

func (r *reportRepository) GetReportsByStatus(ctx context.Context, status string, limit int) ([]models.Report, error) {
	query := `
		SELECT 
			id, work_id, file_id, assignment_id, student_id, status,
			plagiarism_flag, original_work_id, match_percentage, file_hash,
			compared_hashes, details, processing_time_ms, compared_files_count,
			created_at, started_at, completed_at, updated_at
		FROM reports
		WHERE status = $1
		ORDER BY created_at DESC
		LIMIT $2
	`

	rows, err := r.db.QueryContext(ctx, query, status, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		report, err := r.scanReport(rows)
		if err != nil {
			return nil, err
		}
		reports = append(reports, *report)
	}

	return reports, nil
}

func (r *reportRepository) Exists(ctx context.Context, workID string) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM reports WHERE work_id = $1)`
	var exists bool
	err := r.db.QueryRowContext(ctx, query, workID).Scan(&exists)
	return exists, err
}

func (r *reportRepository) scanReport(rows *sql.Rows) (*models.Report, error) {
	report := &models.Report{}
	var comparedHashes []sql.NullString
	var originalWorkID sql.NullString
	var processingTimeMs sql.NullInt64

	err := rows.Scan(
		&report.ID,
		&report.WorkID,
		&report.FileID,
		&report.AssignmentID,
		&report.StudentID,
		&report.Status,
		&report.PlagiarismFlag,
		&originalWorkID,
		&report.MatchPercentage,
		&report.FileHash,
		pq.Array(&comparedHashes),
		&report.Details,
		&processingTimeMs,
		&report.ComparedFilesCount,
		&report.CreatedAt,
		&report.StartedAt,
		&report.CompletedAt,
		&report.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	// Convert nullable fields
	if originalWorkID.Valid {
		report.OriginalWorkID = &originalWorkID.String
	}

	if processingTimeMs.Valid {
		timeMs := int(processingTimeMs.Int64)
		report.ProcessingTimeMs = &timeMs
	}

	// Convert compared hashes
	for _, hash := range comparedHashes {
		if hash.Valid {
			report.ComparedHashes = append(report.ComparedHashes, hash.String)
		}
	}

	return report, nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\analysis_service.go
================================================================================

package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/repository"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/analyzer"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/integration"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/worker/queue"
	"github.com/google/uuid"
	"github.com/rs/zerolog"
)

type AnalysisService interface {
	AnalyzeWork(ctx context.Context, workID, fileID, assignmentID, studentID string) (*models.AnalysisResult, error)
	AnalyzeWorkAsync(ctx context.Context, workID, fileID, assignmentID, studentID string) (string, error)
	GetAnalysisResult(ctx context.Context, workID string) (*models.AnalysisResult, error)
	BatchAnalyze(ctx context.Context, workIDs []string) (*models.BatchAnalysisResponse, error)
	GetServiceStatus(ctx context.Context) (*models.HealthCheckResponse, error)
	RetryFailedAnalyses(ctx context.Context, limit int) (int, error)
}

type analysisService struct {
	reportRepo        repository.ReportRepository
	plagiarismRepo    repository.PlagiarismRepository
	workClient        integration.WorkClient
	fileClient        integration.FileClient
	plagiarismChecker analyzer.PlagiarismChecker
	messageHandler    queue.MessageHandler
	rabbitMQPublisher queue.RabbitMQPublisher
	logger            zerolog.Logger
	config            AnalysisConfig
	mu                sync.RWMutex
}

type AnalysisConfig struct {
	HashAlgorithm       string
	SimilarityThreshold int
	EnableDeepAnalysis  bool
	Timeout             time.Duration
	MaxRetries          int
	BatchSize           int
}

func NewAnalysisService(
	reportRepo repository.ReportRepository,
	plagiarismRepo repository.PlagiarismRepository,
	workClient integration.WorkClient,
	fileClient integration.FileClient,
	plagiarismChecker analyzer.PlagiarismChecker,
	messageHandler queue.MessageHandler,
	rabbitMQPublisher queue.RabbitMQPublisher,
	logger zerolog.Logger,
	config AnalysisConfig,
) AnalysisService {
	return &analysisService{
		reportRepo:        reportRepo,
		plagiarismRepo:    plagiarismRepo,
		workClient:        workClient,
		fileClient:        fileClient,
		plagiarismChecker: plagiarismChecker,
		messageHandler:    messageHandler,
		rabbitMQPublisher: rabbitMQPublisher,
		logger:            logger,
		config:            config,
	}
}

func (s *analysisService) AnalyzeWork(ctx context.Context, workID, fileID, assignmentID, studentID string) (*models.AnalysisResult, error) {
	startTime := time.Now()

	// Check if analysis already exists
	existingReport, err := s.reportRepo.GetByWorkID(ctx, workID)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing report: %w", err)
	}

	if existingReport != nil && existingReport.Status == models.ReportStatusCompleted.String() {
		s.logger.Info().Str("work_id", workID).Msg("Analysis already completed, returning cached result")
		return s.convertReportToResult(existingReport), nil
	}

	// Create or update report
	report := &models.Report{
		ID:           uuid.New().String(),
		WorkID:       workID,
		FileID:       fileID,
		AssignmentID: assignmentID,
		StudentID:    studentID,
		Status:       models.ReportStatusProcessing.String(),
		StartedAt:    &startTime,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	if existingReport != nil {
		report.ID = existingReport.ID
		report.Status = models.ReportStatusProcessing.String()
		report.StartedAt = &startTime
		report.UpdatedAt = time.Now()

		if err := s.reportRepo.UpdateStatus(ctx, report.ID, report.Status); err != nil {
			return nil, fmt.Errorf("failed to update report status: %w", err)
		}
	} else {
		if err := s.reportRepo.Create(ctx, report); err != nil {
			return nil, fmt.Errorf("failed to create report: %w", err)
		}
	}

	// Update work status in Work Service
	if err := s.workClient.UpdateWorkStatus(ctx, workID, "analyzing"); err != nil {
		s.logger.Error().Err(err).Str("work_id", workID).Msg("Failed to update work status")
	}

	// Perform plagiarism check
	result, err := s.plagiarismChecker.CheckPlagiarism(ctx, workID, fileID, assignmentID, studentID)
	if err != nil {
		// Update report with failure
		report.Status = models.ReportStatusFailed.String()
		report.UpdatedAt = time.Now()
		if updateErr := s.reportRepo.UpdateStatus(ctx, report.ID, report.Status); updateErr != nil {
			s.logger.Error().Err(updateErr).Msg("Failed to update failed report")
		}

		// Update work status
		if updateErr := s.workClient.UpdateWorkStatus(ctx, workID, "failed"); updateErr != nil {
			s.logger.Error().Err(updateErr).Msg("Failed to update work status to failed")
		}

		return nil, fmt.Errorf("plagiarism check failed: %w", err)
	}

	// Update report with results
	completedAt := time.Now()
	processingTime := int(completedAt.Sub(startTime).Milliseconds())

	report.Status = models.ReportStatusCompleted.String()
	report.PlagiarismFlag = result.PlagiarismFlag
	report.OriginalWorkID = result.OriginalWorkID
	report.MatchPercentage = result.MatchPercentage
	report.FileHash = result.FileHash
	report.ProcessingTimeMs = &processingTime
	report.ComparedFilesCount = result.ComparedWithCount
	report.CompletedAt = &completedAt
	report.UpdatedAt = completedAt

	// Save compared hashes
	if result.SimilarWorks != nil {
		comparedHashes := make([]string, 0, len(result.SimilarWorks))
		for _, work := range result.SimilarWorks {
			comparedHashes = append(comparedHashes, work.FileHash)
		}
		report.ComparedHashes = comparedHashes
	}

	// Save details
	if result.Details != nil {
		report.Details = result.Details
	}

	// Update report in database
	if err := s.reportRepo.Update(ctx, report); err != nil {
		return nil, fmt.Errorf("failed to update report with results: %w", err)
	}

	// Update work status
	workStatus := "analyzed"
	if result.PlagiarismFlag {
		workStatus = "plagiarized"
	}

	if err := s.workClient.UpdateWorkStatus(ctx, workID, workStatus); err != nil {
		s.logger.Error().Err(err).Msg("Failed to update work status")
	}

	// Publish analysis completed event
	event := models.AnalysisCompletedEvent{
		WorkID:          workID,
		ReportID:        report.ID,
		Status:          report.Status,
		PlagiarismFlag:  report.PlagiarismFlag,
		OriginalWorkID:  report.OriginalWorkID,
		MatchPercentage: report.MatchPercentage,
		ProcessingTime:  processingTime,
		CompletedAt:     completedAt,
	}

	eventJSON, err := json.Marshal(event)
	if err != nil {
		s.logger.Error().Err(err).Msg("Failed to marshal analysis completed event")
	} else {
		if err := s.rabbitMQPublisher.Publish(ctx, "plagiarism_exchange", "analysis.completed", eventJSON); err != nil {
			s.logger.Error().Err(err).Msg("Failed to publish analysis completed event")
		}
	}

	s.logger.Info().
		Str("work_id", workID).
		Bool("plagiarism", result.PlagiarismFlag).
		Int("match_percentage", result.MatchPercentage).
		Int("processing_time_ms", processingTime).
		Msg("Analysis completed successfully")

	return result, nil
}

func (s *analysisService) AnalyzeWorkAsync(ctx context.Context, workID, fileID, assignmentID, studentID string) (string, error) {
	// Create initial report
	reportID := uuid.New().String()
	report := &models.Report{
		ID:           reportID,
		WorkID:       workID,
		FileID:       fileID,
		AssignmentID: assignmentID,
		StudentID:    studentID,
		Status:       models.ReportStatusPending.String(),
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	if err := s.reportRepo.Create(ctx, report); err != nil {
		return "", fmt.Errorf("failed to create report: %w", err)
	}

	// Publish async analysis request
	request := models.PlagiarismCheckRequest{
		WorkID:       workID,
		FileID:       fileID,
		AssignmentID: assignmentID,
		StudentID:    studentID,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return "", fmt.Errorf("failed to marshal analysis request: %w", err)
	}

	if err := s.rabbitMQPublisher.Publish(ctx, "plagiarism_exchange", "analysis.request", requestJSON); err != nil {
		return "", fmt.Errorf("failed to publish analysis request: %w", err)
	}

	s.logger.Info().
		Str("work_id", workID).
		Str("report_id", reportID).
		Msg("Async analysis requested")

	return reportID, nil
}

func (s *analysisService) GetAnalysisResult(ctx context.Context, workID string) (*models.AnalysisResult, error) {
	report, err := s.reportRepo.GetByWorkID(ctx, workID)
	if err != nil {
		return nil, fmt.Errorf("failed to get report: %w", err)
	}

	if report == nil {
		return nil, errors.New("analysis not found for this work")
	}

	return s.convertReportToResult(report), nil
}

func (s *analysisService) BatchAnalyze(ctx context.Context, workIDs []string) (*models.BatchAnalysisResponse, error) {
	startTime := time.Now()

	if len(workIDs) > s.config.BatchSize {
		return nil, fmt.Errorf("batch size exceeds limit of %d", s.config.BatchSize)
	}

	s.logger.Info().
		Int("work_count", len(workIDs)).
		Msg("Starting batch analysis")

	response := &models.BatchAnalysisResponse{
		Total:       len(workIDs),
		Processed:   0,
		Failed:      0,
		Results:     make([]models.PlagiarismCheckResponse, 0, len(workIDs)),
		CompletedAt: time.Now(),
	}

	// Process in batches
	batchSize := 5 // Process 5 works at a time
	for i := 0; i < len(workIDs); i += batchSize {
		end := i + batchSize
		if end > len(workIDs) {
			end = len(workIDs)
		}

		batch := workIDs[i:end]

		// Process batch concurrently
		var wg sync.WaitGroup
		results := make([]models.PlagiarismCheckResponse, len(batch))
		errors := make([]error, len(batch))

		for j, workID := range batch {
			wg.Add(1)
			go func(idx int, wID string) {
				defer wg.Done()

				// Get work info (in real implementation, you'd get fileID, assignmentID, studentID)
				// For now, use placeholder
				result, err := s.AnalyzeWork(ctx, wID, "file_"+wID, "assignment_"+wID, "student_"+wID)
				if err != nil {
					errors[idx] = err
					return
				}

				results[idx] = models.PlagiarismCheckResponse{
					ReportID:        "report_" + wID,
					WorkID:          wID,
					Status:          result.Status,
					PlagiarismFlag:  result.PlagiarismFlag,
					MatchPercentage: result.MatchPercentage,
					OriginalWorkID:  result.OriginalWorkID,
					AnalyzedAt:      result.AnalyzedAt,
				}
			}(j, workID)
		}

		wg.Wait()

		// Collect results
		for j, result := range results {
			if result.WorkID != "" {
				response.Results = append(response.Results, result)
				response.Processed++
			} else if errors[j] != nil {
				s.logger.Error().
					Err(errors[j]).
					Str("work_id", batch[j]).
					Msg("Failed to analyze work in batch")
				response.Failed++
			}
		}
	}

	response.CompletedAt = time.Now()

	s.logger.Info().
		Int("total", response.Total).
		Int("processed", response.Processed).
		Int("failed", response.Failed).
		Dur("duration", response.CompletedAt.Sub(startTime)).
		Msg("Batch analysis completed")

	return response, nil
}

func (s *analysisService) GetServiceStatus(ctx context.Context) (*models.HealthCheckResponse, error) {
	// Check database connection
	dbOK := true
	if err := s.reportRepo.Ping(ctx); err != nil {
		dbOK = false
		s.logger.Error().Err(err).Msg("Database health check failed")
	}

	// Check external services (simplified)
	workServiceOK := true
	fileServiceOK := true

	// Get statistics
	stats, err := s.reportRepo.GetStats(ctx)
	if err != nil {
		s.logger.Error().Err(err).Msg("Failed to get service statistics")
	}

	response := &models.HealthCheckResponse{
		Status:        "healthy",
		Database:      dbOK,
		RabbitMQ:      true, // Would check RabbitMQ connection
		WorkService:   workServiceOK,
		FileService:   fileServiceOK,
		ActiveWorkers: 0,     // Would get from worker pool
		QueueLength:   0,     // Would get from queue
		Uptime:        "24h", // Would calculate actual uptime
		Timestamp:     time.Now(),
	}

	if !dbOK || !workServiceOK || !fileServiceOK {
		response.Status = "degraded"
	}

	return response, nil
}

func (s *analysisService) RetryFailedAnalyses(ctx context.Context, limit int) (int, error) {
	// Get failed reports
	failedReports, err := s.reportRepo.GetReportsByStatus(ctx, models.ReportStatusFailed.String(), limit)
	if err != nil {
		return 0, fmt.Errorf("failed to get failed reports: %w", err)
	}

	retryCount := 0
	for _, report := range failedReports {
		s.logger.Info().
			Str("work_id", report.WorkID).
			Str("report_id", report.ID).
			Msg("Retrying failed analysis")

		// Retry analysis
		_, err := s.AnalyzeWork(ctx, report.WorkID, report.FileID, report.AssignmentID, report.StudentID)
		if err != nil {
			s.logger.Error().
				Err(err).
				Str("work_id", report.WorkID).
				Msg("Failed to retry analysis")
			continue
		}

		retryCount++
	}

	s.logger.Info().
		Int("total_failed", len(failedReports)).
		Int("retried", retryCount).
		Msg("Failed analyses retry completed")

	return retryCount, nil
}

func (s *analysisService) convertReportToResult(report *models.Report) *models.AnalysisResult {
	result := &models.AnalysisResult{
		WorkID:            report.WorkID,
		Status:            report.Status,
		PlagiarismFlag:    report.PlagiarismFlag,
		OriginalWorkID:    report.OriginalWorkID,
		MatchPercentage:   report.MatchPercentage,
		FileHash:          report.FileHash,
		ComparedWithCount: report.ComparedFilesCount,
		AnalyzedAt:        report.UpdatedAt,
	}

	if report.ProcessingTimeMs != nil {
		result.ProcessingTimeMs = *report.ProcessingTimeMs
	}

	// Parse details if available
	if report.Details != nil && len(report.Details) > 0 {
		var details models.ReportDetails
		if err := json.Unmarshal(report.Details, &details); err == nil {
			// Convert comparison results to similar works
			for _, compResult := range details.ComparisonResults {
				similarWork := models.SimilarWork{
					WorkID:          compResult.ComparedWorkID,
					StudentID:       compResult.StudentID,
					MatchPercentage: compResult.MatchPercentage,
					FileHash:        compResult.FileHash,
				}
				result.SimilarWorks = append(result.SimilarWorks, similarWork)
			}
			result.Details = report.Details
		}
	}

	return result
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\report_service.go
================================================================================

package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/repository"
	"github.com/rs/zerolog"
)

type ReportService interface {
	GetReport(ctx context.Context, reportID string) (*models.GetReportResponse, error)
	GetReportByWorkID(ctx context.Context, workID string) (*models.GetReportResponse, error)
	SearchReports(ctx context.Context, filters models.SearchReportsRequest) (*models.SearchReportsResponse, error)
	GetAssignmentStats(ctx context.Context, assignmentID string) (*models.GetAssignmentStatsResponse, error)
	GetStudentStats(ctx context.Context, studentID string) (*models.GetStudentStatsResponse, error)
	GetAllStats(ctx context.Context) (*models.AnalysisStats, error)
	ExportReports(ctx context.Context, filters map[string]interface{}, format string) ([]byte, error)
}

type reportService struct {
	reportRepo     repository.ReportRepository
	plagiarismRepo repository.PlagiarismRepository
	logger         zerolog.Logger
}

func NewReportService(
	reportRepo repository.ReportRepository,
	plagiarismRepo repository.PlagiarismRepository,
	logger zerolog.Logger,
) ReportService {
	return &reportService{
		reportRepo:     reportRepo,
		plagiarismRepo: plagiarismRepo,
		logger:         logger,
	}
}

func (s *reportService) GetReport(ctx context.Context, reportID string) (*models.GetReportResponse, error) {
	report, err := s.reportRepo.GetByID(ctx, reportID)
	if err != nil {
		return nil, fmt.Errorf("failed to get report: %w", err)
	}

	if report == nil {
		return nil, errors.New("report not found")
	}

	return s.convertToResponse(report), nil
}

func (s *reportService) GetReportByWorkID(ctx context.Context, workID string) (*models.GetReportResponse, error) {
	report, err := s.reportRepo.GetByWorkID(ctx, workID)
	if err != nil {
		return nil, fmt.Errorf("failed to get report by work ID: %w", err)
	}

	if report == nil {
		return nil, errors.New("report not found for this work")
	}

	return s.convertToResponse(report), nil
}

func (s *reportService) SearchReports(ctx context.Context, filters models.SearchReportsRequest) (*models.SearchReportsResponse, error) {
	// Convert request filters to repository filters
	repoFilters := make(map[string]interface{})

	if filters.WorkID != nil && *filters.WorkID != "" {
		repoFilters["work_id"] = *filters.WorkID
	}

	if filters.AssignmentID != nil && *filters.AssignmentID != "" {
		repoFilters["assignment_id"] = *filters.AssignmentID
	}

	if filters.StudentID != nil && *filters.StudentID != "" {
		repoFilters["student_id"] = *filters.StudentID
	}

	if filters.Status != nil && *filters.Status != "" {
		repoFilters["status"] = *filters.Status
	}

	if filters.PlagiarismFlag != nil {
		repoFilters["plagiarism_flag"] = *filters.PlagiarismFlag
	}

	if filters.DateFrom != nil && *filters.DateFrom != "" {
		if date, err := time.Parse(time.RFC3339, *filters.DateFrom); err == nil {
			repoFilters["date_from"] = date
		}
	}

	if filters.DateTo != nil && *filters.DateTo != "" {
		if date, err := time.Parse(time.RFC3339, *filters.DateTo); err == nil {
			repoFilters["date_to"] = date
		}
	}

	// Calculate offset
	offset := (filters.Page - 1) * filters.Limit

	// Search reports
	reports, total, err := s.reportRepo.Search(ctx, repoFilters, filters.Limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to search reports: %w", err)
	}

	// Convert to response
	responseReports := make([]models.GetReportResponse, 0, len(reports))
	for _, report := range reports {
		responseReports = append(responseReports, *s.convertToResponse(&report))
	}

	// Calculate total pages
	totalPages := total / filters.Limit
	if total%filters.Limit > 0 {
		totalPages++
	}

	return &models.SearchReportsResponse{
		Reports:    responseReports,
		Total:      total,
		Page:       filters.Page,
		Limit:      filters.Limit,
		TotalPages: totalPages,
	}, nil
}

func (s *reportService) GetAssignmentStats(ctx context.Context, assignmentID string) (*models.GetAssignmentStatsResponse, error) {
	// Get assignment statistics
	stats, err := s.reportRepo.GetAssignmentStats(ctx, assignmentID)
	if err != nil {
		return nil, fmt.Errorf("failed to get assignment stats: %w", err)
	}

	if stats == nil {
		return nil, errors.New("assignment not found or no reports available")
	}

	// Get recent reports for this assignment
	reports, _, err := s.reportRepo.GetByAssignmentID(ctx, assignmentID, 10, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to get assignment reports: %w", err)
	}

	// Convert reports to response
	responseReports := make([]models.GetReportResponse, 0, len(reports))
	for _, report := range reports {
		responseReports = append(responseReports, *s.convertToResponse(&report))
	}

	// Get plagiarism patterns
	patterns, err := s.plagiarismRepo.GetPlagiarismPatterns(ctx, assignmentID)
	if err != nil {
		s.logger.Error().Err(err).Msg("Failed to get plagiarism patterns")
	}

	// Prepare statistics
	statistics := map[string]interface{}{
		"total_reports":         stats.TotalWorks,
		"analyzed_percentage":   float64(stats.AnalyzedWorks) / float64(stats.TotalWorks) * 100,
		"plagiarism_percentage": float64(stats.PlagiarizedWorks) / float64(stats.AnalyzedWorks) * 100,
		"avg_match_percentage":  stats.AvgMatchPercentage,
		"plagiarism_patterns":   patterns,
	}

	return &models.GetAssignmentStatsResponse{
		AssignmentID:       stats.AssignmentID,
		TotalWorks:         stats.TotalWorks,
		AnalyzedWorks:      stats.AnalyzedWorks,
		PlagiarizedWorks:   stats.PlagiarizedWorks,
		AvgMatchPercentage: stats.AvgMatchPercentage,
		Reports:            responseReports,
		Statistics:         statistics,
		LastAnalyzedAt:     stats.LastAnalyzedAt,
	}, nil
}

func (s *reportService) GetStudentStats(ctx context.Context, studentID string) (*models.GetStudentStatsResponse, error) {
	// Get student statistics
	stats, err := s.reportRepo.GetStudentStats(ctx, studentID)
	if err != nil {
		return nil, fmt.Errorf("failed to get student stats: %w", err)
	}

	if stats == nil {
		return nil, errors.New("student not found or no reports available")
	}

	// Get recent reports for this student
	reports, _, err := s.reportRepo.GetByStudentID(ctx, studentID, 10, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to get student reports: %w", err)
	}

	// Convert reports to response
	responseReports := make([]models.GetReportResponse, 0, len(reports))
	for _, report := range reports {
		responseReports = append(responseReports, *s.convertToResponse(&report))
	}

	// Get comparison history for the student's works
	var comparisonHistory []models.ComparisonResult
	for _, report := range reports {
		history, err := s.plagiarismRepo.GetComparisonHistory(ctx, report.WorkID)
		if err != nil {
			s.logger.Error().Err(err).Str("work_id", report.WorkID).Msg("Failed to get comparison history")
			continue
		}
		comparisonHistory = append(comparisonHistory, history...)
	}

	// Prepare statistics
	statistics := map[string]interface{}{
		"total_reports":         stats.TotalWorks,
		"analyzed_percentage":   float64(stats.AnalyzedWorks) / float64(stats.TotalWorks) * 100,
		"plagiarism_percentage": float64(stats.PlagiarizedWorks) / float64(stats.AnalyzedWorks) * 100,
		"avg_match_percentage":  stats.AvgMatchPercentage,
		"comparison_history":    comparisonHistory,
	}

	return &models.GetStudentStatsResponse{
		StudentID:          stats.StudentID,
		TotalWorks:         stats.TotalWorks,
		AnalyzedWorks:      stats.AnalyzedWorks,
		PlagiarizedWorks:   stats.PlagiarizedWorks,
		AvgMatchPercentage: stats.AvgMatchPercentage,
		Reports:            responseReports,
		Statistics:         statistics,
		LastAnalyzedAt:     stats.LastAnalyzedAt,
	}, nil
}

func (s *reportService) GetAllStats(ctx context.Context) (*models.AnalysisStats, error) {
	return s.reportRepo.GetStats(ctx)
}

func (s *reportService) ExportReports(ctx context.Context, filters map[string]interface{}, format string) ([]byte, error) {
	// Get reports based on filters
	reports, _, err := s.reportRepo.Search(ctx, filters, 1000, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to get reports for export: %w", err)
	}

	// Export based on format
	switch format {
	case "json":
		return s.exportJSON(reports)
	case "csv":
		return s.exportCSV(reports)
	default:
		return nil, fmt.Errorf("unsupported export format: %s", format)
	}
}

func (s *reportService) exportJSON(reports []models.Report) ([]byte, error) {
	// Convert to response format first
	responseReports := make([]models.GetReportResponse, 0, len(reports))
	for _, report := range reports {
		responseReports = append(responseReports, *s.convertToResponse(&report))
	}

	return json.MarshalIndent(responseReports, "", "  ")
}

func (s *reportService) exportCSV(reports []models.Report) ([]byte, error) {
	// CSV header
	csvData := "Report ID,Work ID,Assignment ID,Student ID,Status,Plagiarism,Match %,Processing Time (ms),Compared Files,Created At,Completed At\n"

	// CSV rows
	for _, report := range reports {
		completedAt := ""
		if report.CompletedAt != nil {
			completedAt = report.CompletedAt.Format(time.RFC3339)
		}

		csvData += fmt.Sprintf("%s,%s,%s,%s,%s,%v,%d,%d,%d,%s,%s\n",
			report.ID,
			report.WorkID,
			report.AssignmentID,
			report.StudentID,
			report.Status,
			report.PlagiarismFlag,
			report.MatchPercentage,
			func() int {
				if report.ProcessingTimeMs != nil {
					return *report.ProcessingTimeMs
				}
				return 0
			}(),
			report.ComparedFilesCount,
			report.CreatedAt.Format(time.RFC3339),
			completedAt,
		)
	}

	return []byte(csvData), nil
}

func (s *reportService) convertToResponse(report *models.Report) *models.GetReportResponse {
	response := &models.GetReportResponse{
		ReportID:           report.ID,
		WorkID:             report.WorkID,
		FileID:             report.FileID,
		AssignmentID:       report.AssignmentID,
		StudentID:          report.StudentID,
		Status:             report.Status,
		PlagiarismFlag:     report.PlagiarismFlag,
		OriginalWorkID:     report.OriginalWorkID,
		MatchPercentage:    report.MatchPercentage,
		FileHash:           report.FileHash,
		ComparedFilesCount: report.ComparedFilesCount,
		CreatedAt:          report.CreatedAt,
		StartedAt:          report.StartedAt,
		CompletedAt:        report.CompletedAt,
	}

	// Parse details if available
	if report.Details != nil && len(report.Details) > 0 {
		var details map[string]interface{}
		if err := json.Unmarshal(report.Details, &details); err == nil {
			response.Details = details
		}
	}

	// Convert processing time
	if report.ProcessingTimeMs != nil {
		processingTime := *report.ProcessingTimeMs
		response.ProcessingTimeMs = &processingTime
	}

	return response
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\analyzer\hash_comparator.go
================================================================================

package analyzer

import (
	"fmt"
	"strings"
)

type HashComparator interface {
	CompareHashes(hash1, hash2 string) (int, error)
	CompareMultiple(hashes []string, targetHash string) (map[string]int, error)
	GetAlgorithm() string
}

type hashComparator struct {
	algorithm string
}

func NewHashComparator(algorithm string) HashComparator {
	return &hashComparator{
		algorithm: strings.ToLower(algorithm),
	}
}

func (c *hashComparator) CompareHashes(hash1, hash2 string) (int, error) {
	// Normalize hashes (remove any whitespace, convert to lowercase)
	hash1 = strings.ToLower(strings.TrimSpace(hash1))
	hash2 = strings.ToLower(strings.TrimSpace(hash2))

	// Check hash lengths
	if len(hash1) != len(hash2) {
		return 0, fmt.Errorf("hash lengths don't match: %d vs %d", len(hash1), len(hash2))
	}

	// For exact comparison (binary comparison)
	if hash1 == hash2 {
		return 100, nil
	}

	// For partial comparison (character by character)
	// This is a simple implementation - for real use, you might want more sophisticated comparison
	matchingChars := 0
	for i := 0; i < len(hash1); i++ {
		if hash1[i] == hash2[i] {
			matchingChars++
		}
	}

	// Calculate percentage
	percentage := (matchingChars * 100) / len(hash1)
	return percentage, nil
}

func (c *hashComparator) CompareMultiple(hashes []string, targetHash string) (map[string]int, error) {
	results := make(map[string]int)

	for _, hash := range hashes {
		percentage, err := c.CompareHashes(targetHash, hash)
		if err != nil {
			return nil, err
		}
		results[hash] = percentage
	}

	return results, nil
}

func (c *hashComparator) GetAlgorithm() string {
	return c.algorithm
}

// AdvancedHashComparator provides more sophisticated hash comparison
type AdvancedHashComparator struct {
	hashComparator HashComparator
	threshold      int
}

func NewAdvancedHashComparator(algorithm string, threshold int) *AdvancedHashComparator {
	return &AdvancedHashComparator{
		hashComparator: NewHashComparator(algorithm),
		threshold:      threshold,
	}
}

func (c *AdvancedHashComparator) CompareHashes(hash1, hash2 string) (int, error) {
	return c.hashComparator.CompareHashes(hash1, hash2)
}

func (c *AdvancedHashComparator) CompareMultiple(hashes []string, targetHash string) (map[string]int, error) {
	return c.hashComparator.CompareMultiple(hashes, targetHash)
}

func (c *AdvancedHashComparator) GetAlgorithm() string {
	return c.hashComparator.GetAlgorithm()
}

func (c *AdvancedHashComparator) FindMatches(targetHash string, candidateHashes []string) ([]string, error) {
	var matches []string

	for _, candidate := range candidateHashes {
		percentage, err := c.CompareHashes(targetHash, candidate)
		if err != nil {
			return nil, err
		}

		if percentage >= c.threshold {
			matches = append(matches, candidate)
		}
	}

	return matches, nil
}

func (c *AdvancedHashComparator) GetSimilarityScore(hash1, hash2 string) (float64, error) {
	percentage, err := c.CompareHashes(hash1, hash2)
	if err != nil {
		return 0, err
	}

	// Convert to float for more precise calculations
	return float64(percentage) / 100.0, nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\analyzer\plagiarism_checker.go
================================================================================

package analyzer

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/integration"
	"github.com/rs/zerolog"
)

type PlagiarismChecker interface {
	CheckPlagiarism(ctx context.Context, workID, fileID, assignmentID, studentID string) (*models.AnalysisResult, error)
	BatchCheck(ctx context.Context, requests []models.PlagiarismCheckRequest) ([]models.AnalysisResult, error)
	GetCheckerInfo() CheckerInfo
}

type CheckerInfo struct {
	Name        string `json:"name"`
	Version     string `json:"version"`
	Algorithm   string `json:"algorithm"`
	Description string `json:"description"`
}

type plagiarismChecker struct {
	workClient     integration.WorkClient
	fileClient     integration.FileClient
	hashComparator HashComparator
	logger         zerolog.Logger
	config         PlagiarismCheckerConfig
}

type PlagiarismCheckerConfig struct {
	HashAlgorithm       string
	SimilarityThreshold int
	EnableDeepAnalysis  bool
	Timeout             time.Duration
	MaxRetries          int
}

func NewPlagiarismChecker(
	workClient integration.WorkClient,
	fileClient integration.FileClient,
	hashComparator HashComparator,
	logger zerolog.Logger,
	config PlagiarismCheckerConfig,
) PlagiarismChecker {
	return &plagiarismChecker{
		workClient:     workClient,
		fileClient:     fileClient,
		hashComparator: hashComparator,
		logger:         logger,
		config:         config,
	}
}

func (c *plagiarismChecker) CheckPlagiarism(ctx context.Context, workID, fileID, assignmentID, studentID string) (*models.AnalysisResult, error) {
	startTime := time.Now()

	c.logger.Info().
		Str("work_id", workID).
		Str("file_id", fileID).
		Str("assignment_id", assignmentID).
		Msg("Starting plagiarism check")

	// Get current file hash
	currentFileHash, currentFileSize, err := c.fileClient.GetFileHash(ctx, fileID)
	if err != nil {
		return nil, fmt.Errorf("failed to get current file hash: %w", err)
	}

	c.logger.Debug().
		Str("work_id", workID).
		Str("file_hash", currentFileHash).
		Int64("file_size", currentFileSize).
		Msg("Got current file hash")

	// Get previous works for this assignment
	previousWorks, err := c.workClient.GetPreviousWorks(ctx, assignmentID, workID)
	if err != nil {
		return nil, fmt.Errorf("failed to get previous works: %w", err)
	}

	c.logger.Debug().
		Str("work_id", workID).
		Int("previous_works_count", len(previousWorks)).
		Msg("Got previous works")

	// Prepare results
	result := &models.AnalysisResult{
		WorkID:            workID,
		Status:            "processing",
		FileHash:          currentFileHash,
		ComparedWithCount: len(previousWorks),
		AnalyzedAt:        time.Now(),
	}

	// If no previous works, return immediately
	if len(previousWorks) == 0 {
		result.Status = "completed"
		result.PlagiarismFlag = false
		result.MatchPercentage = 0
		result.ProcessingTimeMs = int(time.Since(startTime).Milliseconds())

		c.logger.Info().
			Str("work_id", workID).
			Msg("No previous works to compare with")

		return result, nil
	}

	// Compare with each previous work
	var similarWorks []models.SimilarWork
	var highestMatch int = 0
	var originalWorkID *string

	comparedHashes := make([]string, 0, len(previousWorks))

	for _, prevWork := range previousWorks {
		// Get previous file hash
		prevFileHash, prevFileSize, err := c.fileClient.GetFileHash(ctx, prevWork.FileID)
		if err != nil {
			c.logger.Error().
				Err(err).
				Str("prev_work_id", prevWork.ID).
				Str("prev_file_id", prevWork.FileID).
				Msg("Failed to get previous file hash")
			continue
		}

		// Compare hashes
		matchPercentage, err := c.hashComparator.CompareHashes(currentFileHash, prevFileHash)
		if err != nil {
			c.logger.Error().
				Err(err).
				Str("prev_work_id", prevWork.ID).
				Msg("Failed to compare hashes")
			continue
		}

		comparedHashes = append(comparedHashes, prevFileHash)

		// Record similarity
		similarWork := models.SimilarWork{
			WorkID:          prevWork.ID,
			StudentID:       prevWork.StudentID,
			MatchPercentage: matchPercentage,
			FileHash:        prevFileHash,
			SubmittedAt:     prevWork.CreatedAt,
		}
		similarWorks = append(similarWorks, similarWork)

		// Update highest match
		if matchPercentage > highestMatch {
			highestMatch = matchPercentage

			// If match is 100% and from different student, mark as plagiarism
			if matchPercentage == 100 && prevWork.StudentID != studentID {
				originalWorkID = &prevWork.ID
			}
		}

		c.logger.Debug().
			Str("work_id", workID).
			Str("prev_work_id", prevWork.ID).
			Int("match_percentage", matchPercentage).
			Msg("Compared with previous work")
	}

	// Determine if plagiarism is detected
	plagiarismDetected := false
	if highestMatch >= c.config.SimilarityThreshold {
		// Only flag as plagiarism if the match is with a different student
		if originalWorkID != nil {
			plagiarismDetected = true
		}
	}

	// Prepare result details
	details := models.ReportDetails{
		ComparisonResults: make([]models.ComparisonResult, 0, len(similarWorks)),
		FileInfo: models.FileInfo{
			FileSize: currentFileSize,
		},
		AnalysisMetadata: models.AnalysisMetadata{
			AlgorithmUsed:    c.config.HashAlgorithm,
			SimilarityMethod: "hash_comparison",
			AnalysisVersion:  "1.0",
			Threshold:        c.config.SimilarityThreshold,
			StartedAt:        startTime,
			CompletedAt:      time.Now(),
		},
	}

	for _, work := range similarWorks {
		details.ComparisonResults = append(details.ComparisonResults, models.ComparisonResult{
			ComparedWorkID:  work.WorkID,
			StudentID:       work.StudentID,
			MatchPercentage: work.MatchPercentage,
			FileHash:        work.FileHash,
			ComparedAt:      time.Now().Format(time.RFC3339),
		})
	}

	detailsJSON, _ := json.Marshal(details)

	// Complete result
	result.Status = "completed"
	result.PlagiarismFlag = plagiarismDetected
	result.OriginalWorkID = originalWorkID
	result.MatchPercentage = highestMatch
	result.SimilarWorks = similarWorks
	result.ProcessingTimeMs = int(time.Since(startTime).Milliseconds())
	result.Details = detailsJSON

	c.logger.Info().
		Str("work_id", workID).
		Bool("plagiarism_detected", plagiarismDetected).
		Int("match_percentage", highestMatch).
		Int("compared_with", len(previousWorks)).
		Int("processing_time_ms", result.ProcessingTimeMs).
		Msg("Plagiarism check completed")

	return result, nil
}

func (c *plagiarismChecker) BatchCheck(ctx context.Context, requests []models.PlagiarismCheckRequest) ([]models.AnalysisResult, error) {
	results := make([]models.AnalysisResult, 0, len(requests))

	for _, req := range requests {
		result, err := c.CheckPlagiarism(ctx, req.WorkID, req.FileID, req.AssignmentID, req.StudentID)
		if err != nil {
			c.logger.Error().
				Err(err).
				Str("work_id", req.WorkID).
				Msg("Failed to check plagiarism in batch")

			// Create failed result
			failedResult := &models.AnalysisResult{
				WorkID:     req.WorkID,
				Status:     "failed",
				AnalyzedAt: time.Now(),
			}
			results = append(results, *failedResult)
			continue
		}

		results = append(results, *result)
	}

	return results, nil
}

func (c *plagiarismChecker) GetCheckerInfo() CheckerInfo {
	return CheckerInfo{
		Name:        "Plagiarism Checker",
		Version:     "1.0.0",
		Algorithm:   c.config.HashAlgorithm,
		Description: "Checks for plagiarism by comparing file hashes",
	}
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\analyzer\similarity_analyzer.go
================================================================================

package analyzer

import (
	"bytes"
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service/integration"
	"github.com/rs/zerolog"
)

type SimilarityAnalyzer interface {
	AnalyzeContent(ctx context.Context, file1, file2 []byte) (float64, error)
	ExtractText(content []byte) (string, error)
	CalculateSimilarity(text1, text2 string) float64
	FindSimilarSections(text1, text2 string, minLength int) []SimilarSection
}

type SimilarSection struct {
	Text1Start int     `json:"text1_start"`
	Text1End   int     `json:"text1_end"`
	Text2Start int     `json:"text2_start"`
	Text2End   int     `json:"text2_end"`
	Similarity float64 `json:"similarity"`
	Text       string  `json:"text"`
}

type similarityAnalyzer struct {
	fileClient integration.FileClient
	logger     zerolog.Logger
}

func NewSimilarityAnalyzer(fileClient integration.FileClient, logger zerolog.Logger) SimilarityAnalyzer {
	return &similarityAnalyzer{
		fileClient: fileClient,
		logger:     logger,
	}
}

func (a *similarityAnalyzer) AnalyzeContent(ctx context.Context, file1, file2 []byte) (float64, error) {
	startTime := time.Now()

	// Extract text from files
	text1, err := a.ExtractText(file1)
	if err != nil {
		return 0, fmt.Errorf("failed to extract text from first file: %w", err)
	}

	text2, err := a.ExtractText(file2)
	if err != nil {
		return 0, fmt.Errorf("failed to extract text from second file: %w", err)
	}

	// Calculate similarity
	similarity := a.CalculateSimilarity(text1, text2)

	a.logger.Debug().
		Int("text1_length", len(text1)).
		Int("text2_length", len(text2)).
		Float64("similarity", similarity).
		Dur("processing_time", time.Since(startTime)).
		Msg("Content analysis completed")

	return similarity, nil
}

func (a *similarityAnalyzer) ExtractText(content []byte) (string, error) {
	// Simple text extraction - in real implementation you would:
	// 1. Detect file type (PDF, DOC, TXT, etc.)
	// 2. Use appropriate library to extract text
	// 3. Clean and normalize text

	// For now, just convert to string and clean
	text := string(content)

	// Remove extra whitespace
	text = strings.Join(strings.Fields(text), " ")

	// Convert to lowercase for comparison
	text = strings.ToLower(text)

	return text, nil
}

func (a *similarityAnalyzer) CalculateSimilarity(text1, text2 string) float64 {
	// Simple similarity calculation using Jaccard similarity
	// In real implementation, you might use:
	// - Cosine similarity with TF-IDF
	// - Levenshtein distance
	// - More sophisticated NLP techniques

	if text1 == "" || text2 == "" {
		return 0.0
	}

	// Tokenize texts
	tokens1 := strings.Fields(text1)
	tokens2 := strings.Fields(text2)

	// Create sets
	set1 := make(map[string]bool)
	for _, token := range tokens1 {
		set1[token] = true
	}

	set2 := make(map[string]bool)
	for _, token := range tokens2 {
		set2[token] = true
	}

	// Calculate intersection and union
	intersection := 0
	for token := range set1 {
		if set2[token] {
			intersection++
		}
	}

	union := len(set1) + len(set2) - intersection

	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

func (a *similarityAnalyzer) FindSimilarSections(text1, text2 string, minLength int) []SimilarSection {
	var sections []SimilarSection

	// Simple algorithm to find similar sections
	// In real implementation, use more sophisticated algorithms like:
	// - Longest Common Substring
	// - Smith-Waterman algorithm for local alignment

	words1 := strings.Fields(text1)
	words2 := strings.Fields(text2)

	// Create n-grams
	ngrams1 := a.createNGrams(words1, minLength)
	ngrams2 := a.createNGrams(words2, minLength)

	// Find matching n-grams
	for i, gram1 := range ngrams1 {
		for j, gram2 := range ngrams2 {
			similarity := a.CalculateSimilarity(gram1, gram2)
			if similarity > 0.8 { // High similarity threshold
				section := SimilarSection{
					Text1Start: i,
					Text1End:   i + minLength - 1,
					Text2Start: j,
					Text2End:   j + minLength - 1,
					Similarity: similarity,
					Text:       gram1,
				}
				sections = append(sections, section)
			}
		}
	}

	return sections
}

func (a *similarityAnalyzer) createNGrams(words []string, n int) []string {
	if n > len(words) {
		return []string{}
	}

	ngrams := make([]string, len(words)-n+1)
	for i := 0; i <= len(words)-n; i++ {
		ngrams[i] = strings.Join(words[i:i+n], " ")
	}
	return ngrams
}

// TextSimilarityCalculator provides text-based similarity analysis
type TextSimilarityCalculator struct {
	analyzer SimilarityAnalyzer
}

func NewTextSimilarityCalculator(analyzer SimilarityAnalyzer) *TextSimilarityCalculator {
	return &TextSimilarityCalculator{
		analyzer: analyzer,
	}
}

func (c *TextSimilarityCalculator) CompareFiles(ctx context.Context, file1ID, file2ID string) (float64, error) {
	// Get file contents
	// In real implementation, you would download files from storage
	// For now, return placeholder
	return 0.0, nil
}

func (c *TextSimilarityCalculator) GenerateReport(text1, text2 string, similarity float64) models.ReportDetails {
	// Find similar sections
	sections := c.analyzer.FindSimilarSections(text1, text2, 10)

	// Create report
	details := models.ReportDetails{
		AnalysisMetadata: models.AnalysisMetadata{
			AlgorithmUsed:    "text_similarity",
			SimilarityMethod: "jaccard_similarity",
			AnalysisVersion:  "1.0",
			Threshold:        80,
			StartedAt:        time.Now(),
			CompletedAt:      time.Now(),
		},
	}

	// Convert sections to comparison results
	for i, section := range sections {
		details.ComparisonResults = append(details.ComparisonResults, models.ComparisonResult{
			ComparedWorkID:  fmt.Sprintf("section_%d", i),
			MatchPercentage: int(section.Similarity * 100),
			ComparedAt:      time.Now().Format(time.RFC3339),
		})
	}

	return details
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\integration\file_client.go
================================================================================

package integration

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/rs/zerolog"
)

type FileClient interface {
	GetFileHash(ctx context.Context, fileID string) (string, int64, error)
	GetFileContent(ctx context.Context, fileID string) ([]byte, error)
	GetFileInfo(ctx context.Context, fileID string) (*FileInfoResponse, error)
}

type fileClient struct {
	baseURL    string
	timeout    time.Duration
	retryCount int
	retryDelay time.Duration
	client     *http.Client
	logger     zerolog.Logger
}

type FileInfoResponse struct {
	FileID   string `json:"file_id"`
	Hash     string `json:"hash"`
	Size     int64  `json:"size"`
	FileName string `json:"file_name"`
	MimeType string `json:"mime_type"`
}

func NewFileClient(baseURL string, timeout time.Duration, retryCount int, retryDelay time.Duration, logger zerolog.Logger) FileClient {
	return &fileClient{
		baseURL:    baseURL,
		timeout:    timeout,
		retryCount: retryCount,
		retryDelay: retryDelay,
		client: &http.Client{
			Timeout: timeout,
		},
		logger: logger,
	}
}

func (c *fileClient) GetFileHash(ctx context.Context, fileID string) (string, int64, error) {
	url := fmt.Sprintf("%s/files/%s/info", c.baseURL, fileID)

	var fileInfo *FileInfoResponse
	var lastErr error

	for i := 0; i <= c.retryCount; i++ {
		if i > 0 {
			c.logger.Warn().Int("attempt", i).Msg("Retrying file hash fetch")
			time.Sleep(c.retryDelay * time.Duration(i))
		}

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			lastErr = fmt.Errorf("failed to create request: %w", err)
			continue
		}

		resp, err := c.client.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("failed to get file hash: %w", err)
			if resp != nil {
				resp.Body.Close()
			}
			continue
		}

		if resp.StatusCode == http.StatusOK {
			if err := json.NewDecoder(resp.Body).Decode(&fileInfo); err != nil {
				resp.Body.Close()
				lastErr = fmt.Errorf("failed to decode response: %w", err)
				continue
			}
			resp.Body.Close()

			c.logger.Debug().
				Str("file_id", fileID).
				Str("hash", fileInfo.Hash).
				Int64("size", fileInfo.Size).
				Msg("Got file hash")

			return fileInfo.Hash, fileInfo.Size, nil
		}

		if resp.StatusCode == http.StatusNotFound {
			resp.Body.Close()
			return "", 0, fmt.Errorf("file not found: %s", fileID)
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		lastErr = fmt.Errorf("file service returned status %d: %s", resp.StatusCode, string(body))
	}

	return "", 0, fmt.Errorf("failed to get file hash after %d attempts: %w", c.retryCount+1, lastErr)
}

func (c *fileClient) GetFileContent(ctx context.Context, fileID string) ([]byte, error) {
	url := fmt.Sprintf("%s/files/%s", c.baseURL, fileID)

	var lastErr error

	for i := 0; i <= c.retryCount; i++ {
		if i > 0 {
			c.logger.Warn().Int("attempt", i).Msg("Retrying file content fetch")
			time.Sleep(c.retryDelay * time.Duration(i))
		}

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			lastErr = fmt.Errorf("failed to create request: %w", err)
			continue
		}

		resp, err := c.client.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("failed to get file content: %w", err)
			if resp != nil {
				resp.Body.Close()
			}
			continue
		}

		if resp.StatusCode == http.StatusOK {
			content, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				lastErr = fmt.Errorf("failed to read response body: %w", err)
				continue
			}

			c.logger.Debug().
				Str("file_id", fileID).
				Int("content_size", len(content)).
				Msg("Got file content")

			return content, nil
		}

		if resp.StatusCode == http.StatusNotFound {
			resp.Body.Close()
			return nil, fmt.Errorf("file not found: %s", fileID)
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		lastErr = fmt.Errorf("file service returned status %d: %s", resp.StatusCode, string(body))
	}

	return nil, fmt.Errorf("failed to get file content after %d attempts: %w", c.retryCount+1, lastErr)
}

func (c *fileClient) GetFileInfo(ctx context.Context, fileID string) (*FileInfoResponse, error) {
	url := fmt.Sprintf("%s/files/%s/info", c.baseURL, fileID)

	var fileInfo *FileInfoResponse
	var lastErr error

	for i := 0; i <= c.retryCount; i++ {
		if i > 0 {
			c.logger.Warn().Int("attempt", i).Msg("Retrying file info fetch")
			time.Sleep(c.retryDelay * time.Duration(i))
		}

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			lastErr = fmt.Errorf("failed to create request: %w", err)
			continue
		}

		resp, err := c.client.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("failed to get file info: %w", err)
			if resp != nil {
				resp.Body.Close()
			}
			continue
		}

		if resp.StatusCode == http.StatusOK {
			if err := json.NewDecoder(resp.Body).Decode(&fileInfo); err != nil {
				resp.Body.Close()
				lastErr = fmt.Errorf("failed to decode response: %w", err)
				continue
			}
			resp.Body.Close()
			return fileInfo, nil
		}

		if resp.StatusCode == http.StatusNotFound {
			resp.Body.Close()
			return nil, nil
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		lastErr = fmt.Errorf("file service returned status %d: %s", resp.StatusCode, string(body))
	}

	return nil, fmt.Errorf("failed to get file info after %d attempts: %w", c.retryCount+1, lastErr)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\service\integration\work_client.go
================================================================================

package integration

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/rs/zerolog"
)

type WorkClient interface {
	GetPreviousWorks(ctx context.Context, assignmentID, excludeWorkID string) ([]models.SimilarWork, error)
	GetWorkInfo(ctx context.Context, workID string) (*models.SimilarWork, error)
	UpdateWorkStatus(ctx context.Context, workID, status string) error
}

type workClient struct {
	baseURL    string
	timeout    time.Duration
	retryCount int
	retryDelay time.Duration
	client     *http.Client
	logger     zerolog.Logger
}

func NewWorkClient(baseURL string, timeout time.Duration, retryCount int, retryDelay time.Duration, logger zerolog.Logger) WorkClient {
	return &workClient{
		baseURL:    baseURL,
		timeout:    timeout,
		retryCount: retryCount,
		retryDelay: retryDelay,
		client: &http.Client{
			Timeout: timeout,
		},
		logger: logger,
	}
}

func (c *workClient) GetPreviousWorks(ctx context.Context, assignmentID, excludeWorkID string) ([]models.SimilarWork, error) {
	// In real implementation, this would call Work Service API
	// For now, return mock data or implement actual HTTP call

	c.logger.Debug().
		Str("assignment_id", assignmentID).
		Str("exclude_work_id", excludeWorkID).
		Msg("Getting previous works")

	// This is a placeholder - in real implementation, make HTTP request
	return []models.SimilarWork{}, nil
}

func (c *workClient) GetWorkInfo(ctx context.Context, workID string) (*models.SimilarWork, error) {
	url := fmt.Sprintf("%s/works/%s", c.baseURL, workID)

	var workInfo *models.SimilarWork
	var lastErr error

	for i := 0; i <= c.retryCount; i++ {
		if i > 0 {
			c.logger.Warn().Int("attempt", i).Msg("Retrying work info fetch")
			time.Sleep(c.retryDelay * time.Duration(i))
		}

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			lastErr = fmt.Errorf("failed to create request: %w", err)
			continue
		}

		resp, err := c.client.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("failed to get work info: %w", err)
			if resp != nil {
				resp.Body.Close()
			}
			continue
		}

		if resp.StatusCode == http.StatusOK {
			if err := json.NewDecoder(resp.Body).Decode(&workInfo); err != nil {
				resp.Body.Close()
				lastErr = fmt.Errorf("failed to decode response: %w", err)
				continue
			}
			resp.Body.Close()
			return workInfo, nil
		}

		if resp.StatusCode == http.StatusNotFound {
			resp.Body.Close()
			return nil, nil
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		lastErr = fmt.Errorf("work service returned status %d: %s", resp.StatusCode, string(body))
	}

	return nil, fmt.Errorf("failed to get work info after %d attempts: %w", c.retryCount+1, lastErr)
}

func (c *workClient) UpdateWorkStatus(ctx context.Context, workID, status string) error {
	url := fmt.Sprintf("%s/works/%s/status", c.baseURL, workID)

	updateReq := map[string]string{
		"status": status,
	}

	body, err := json.Marshal(updateReq)
	if err != nil {
		return fmt.Errorf("failed to marshal request: %w", err)
	}

	var lastErr error
	for i := 0; i <= c.retryCount; i++ {
		if i > 0 {
			c.logger.Warn().Int("attempt", i).Msg("Retrying work status update")
			time.Sleep(c.retryDelay * time.Duration(i))
		}

		req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewBuffer(body))
		if err != nil {
			lastErr = fmt.Errorf("failed to create request: %w", err)
			continue
		}
		req.Header.Set("Content-Type", "application/json")

		resp, err := c.client.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("failed to update work status: %w", err)
			if resp != nil {
				resp.Body.Close()
			}
			continue
		}

		if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusNoContent {
			resp.Body.Close()
			c.logger.Info().
				Str("work_id", workID).
				Str("status", status).
				Msg("Work status updated")
			return nil
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		lastErr = fmt.Errorf("work service returned status %d: %s", resp.StatusCode, string(body))
	}

	return fmt.Errorf("failed to update work status after %d attempts: %w", c.retryCount+1, lastErr)
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\worker\analysis_worker.go
================================================================================

package worker

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/repository"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/service"
	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/worker/queue"
	"github.com/rs/zerolog"
)

type AnalysisWorker interface {
	Start(ctx context.Context) error
	Stop() error
	ProcessWork(ctx context.Context, workID, fileID, assignmentID, studentID string) error
	GetStats() WorkerStats
}

type WorkerStats struct {
	ActiveWorkers  int `json:"active_workers"`
	ProcessedToday int `json:"processed_today"`
	TotalProcessed int `json:"total_processed"`
	FailedJobs     int `json:"failed_jobs"`
	QueueLength    int `json:"queue_length"`
}

type analysisWorker struct {
	workerPool      *WorkerPool
	queueConsumer   queue.RabbitMQConsumer
	reportRepo      repository.ReportRepository
	analysisService service.AnalysisService
	logger          zerolog.Logger
	stats           WorkerStats
	statsMutex      sync.RWMutex
	startTime       time.Time
}

func NewAnalysisWorker(
	workerPool *WorkerPool,
	queueConsumer queue.RabbitMQConsumer,
	reportRepo repository.ReportRepository,
	analysisService service.AnalysisService,
	logger zerolog.Logger,
) AnalysisWorker {
	return &analysisWorker{
		workerPool:      workerPool,
		queueConsumer:   queueConsumer,
		reportRepo:      reportRepo,
		analysisService: analysisService,
		logger:          logger,
		stats:           WorkerStats{},
		startTime:       time.Now(),
	}
}

func (w *analysisWorker) Start(ctx context.Context) error {
	w.logger.Info().Msg("Starting analysis worker...")

	// Start worker pool
	if err := w.workerPool.Start(ctx); err != nil {
		return fmt.Errorf("failed to start worker pool: %w", err)
	}

	// Start consuming messages
	msgs, err := w.queueConsumer.Consume(ctx)
	if err != nil {
		return fmt.Errorf("failed to start consuming messages: %w", err)
	}

	// Start message processing loop
	go w.processMessages(ctx, msgs)

	w.logger.Info().Msg("Analysis worker started successfully")
	return nil
}

func (w *analysisWorker) Stop() error {
	w.logger.Info().Msg("Stopping analysis worker...")

	// Stop worker pool
	if err := w.workerPool.Stop(); err != nil {
		w.logger.Error().Err(err).Msg("Failed to stop worker pool")
	}

	// Close queue consumer
	if err := w.queueConsumer.Close(); err != nil {
		w.logger.Error().Err(err).Msg("Failed to close queue consumer")
	}

	w.logger.Info().
		Int("total_processed", w.stats.TotalProcessed).
		Int("failed_jobs", w.stats.FailedJobs).
		Dur("uptime", time.Since(w.startTime)).
		Msg("Analysis worker stopped")

	return nil
}

func (w *analysisWorker) processMessages(ctx context.Context, msgs <-chan queue.RabbitMQMessage) {
	for {
		select {
		case <-ctx.Done():
			w.logger.Info().Msg("Stopping message processing")
			return
		case msg, ok := <-msgs:
			if !ok {
				w.logger.Warn().Msg("Message channel closed")
				return
			}

			// Process message in worker pool
			w.workerPool.Submit(func() {
				if err := w.processMessage(ctx, msg); err != nil {
					w.logger.Error().Err(err).Msg("Failed to process message")

					// Update stats
					w.statsMutex.Lock()
					w.stats.FailedJobs++
					w.statsMutex.Unlock()

					// Nack the message (requeue)
					if err := msg.Nack(false, true); err != nil {
						w.logger.Error().Err(err).Msg("Failed to nack message")
					}
				} else {
					// Ack the message
					if err := msg.Ack(false); err != nil {
						w.logger.Error().Err(err).Msg("Failed to ack message")
					}

					// Update stats
					w.statsMutex.Lock()
					w.stats.TotalProcessed++
					if time.Since(msg.Timestamp).Hours() < 24 {
						w.stats.ProcessedToday++
					}
					w.statsMutex.Unlock()
				}
			})
		}
	}
}

func (w *analysisWorker) processMessage(ctx context.Context, msg queue.RabbitMQMessage) error {
	// Parse work created event
	var event models.WorkCreatedEvent
	if err := json.Unmarshal(msg.Body, &event); err != nil {
		return fmt.Errorf("failed to unmarshal event: %w", err)
	}

	w.logger.Info().
		Str("work_id", event.WorkID).
		Str("file_id", event.FileID).
		Str("assignment_id", event.AssignmentID).
		Msg("Processing work analysis")

	// Process the work
	return w.ProcessWork(ctx, event.WorkID, event.FileID, event.AssignmentID, event.StudentID)
}

func (w *analysisWorker) ProcessWork(ctx context.Context, workID, fileID, assignmentID, studentID string) error {
	startTime := time.Now()

	// Check if report already exists
	exists, err := w.reportRepo.Exists(ctx, workID)
	if err != nil {
		return fmt.Errorf("failed to check if report exists: %w", err)
	}

	if exists {
		w.logger.Warn().
			Str("work_id", workID).
			Msg("Report already exists, skipping")
		return nil
	}

	// Create initial report
	report := &models.Report{
		ID:           fmt.Sprintf("report_%s", workID),
		WorkID:       workID,
		FileID:       fileID,
		AssignmentID: assignmentID,
		StudentID:    studentID,
		Status:       models.ReportStatusProcessing.String(),
		CreatedAt:    time.Now(),
		StartedAt:    &startTime,
		UpdatedAt:    time.Now(),
	}

	if err := w.reportRepo.Create(ctx, report); err != nil {
		return fmt.Errorf("failed to create report: %w", err)
	}

	// Perform plagiarism check
	result, err := w.analysisService.AnalyzeWork(ctx, workID, fileID, assignmentID, studentID)
	if err != nil {
		// Update report with failure
		report.Status = models.ReportStatusFailed.String()
		report.UpdatedAt = time.Now()
		if updateErr := w.reportRepo.Update(ctx, report); updateErr != nil {
			w.logger.Error().Err(updateErr).Msg("Failed to update failed report")
		}

		return fmt.Errorf("failed to analyze work: %w", err)
	}

	// Update report with results
	completedAt := time.Now()
	processingTime := int(completedAt.Sub(startTime).Milliseconds())

	report.Status = models.ReportStatusCompleted.String()
	report.PlagiarismFlag = result.PlagiarismFlag
	report.OriginalWorkID = result.OriginalWorkID
	report.MatchPercentage = result.MatchPercentage
	report.FileHash = result.FileHash
	report.ProcessingTimeMs = &processingTime
	report.ComparedFilesCount = result.ComparedWithCount
	report.CompletedAt = &completedAt
	report.UpdatedAt = completedAt

	// Convert details to JSON
	if result.Details != nil {
		report.Details = result.Details
	}

	// Save updated report
	if err := w.reportRepo.Update(ctx, report); err != nil {
		return fmt.Errorf("failed to update report with results: %w", err)
	}

	w.logger.Info().
		Str("work_id", workID).
		Bool("plagiarism_detected", result.PlagiarismFlag).
		Int("match_percentage", result.MatchPercentage).
		Int("processing_time_ms", processingTime).
		Int("compared_files", result.ComparedWithCount).
		Msg("Work analysis completed")

	return nil
}

func (w *analysisWorker) GetStats() WorkerStats {
	w.statsMutex.RLock()
	defer w.statsMutex.RUnlock()

	// Get current queue length
	queueLength, err := w.queueConsumer.GetQueueLength()
	if err != nil {
		w.logger.Error().Err(err).Msg("Failed to get queue length")
	} else {
		w.stats.QueueLength = queueLength
	}

	// Get active workers
	w.stats.ActiveWorkers = w.workerPool.GetActiveWorkers()

	return w.stats
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\worker\worker_pool.go
================================================================================

package worker

import (
	"context"
	"sync"
	"time"

	"github.com/rs/zerolog"
)

type Task func()

type WorkerPool struct {
	tasks         chan Task
	wg            sync.WaitGroup
	activeWorkers int
	maxWorkers    int
	logger        zerolog.Logger
	mu            sync.RWMutex
	shutdown      chan struct{}
}

func NewWorkerPool(maxWorkers int, logger zerolog.Logger) *WorkerPool {
	return &WorkerPool{
		tasks:      make(chan Task, maxWorkers*10),
		maxWorkers: maxWorkers,
		logger:     logger,
		shutdown:   make(chan struct{}),
	}
}

func (wp *WorkerPool) Start(ctx context.Context) error {
	wp.logger.Info().Int("max_workers", wp.maxWorkers).Msg("Starting worker pool")

	// Start workers
	for i := 0; i < wp.maxWorkers; i++ {
		wp.wg.Add(1)
		go wp.worker(i)
	}

	wp.logger.Info().Int("workers_started", wp.maxWorkers).Msg("Worker pool started")
	return nil
}

func (wp *WorkerPool) Stop() error {
	wp.logger.Info().Msg("Stopping worker pool")

	// Close tasks channel to stop receiving new tasks
	close(wp.tasks)

	// Wait for all workers to finish
	wp.wg.Wait()

	// Close shutdown channel
	close(wp.shutdown)

	wp.logger.Info().Msg("Worker pool stopped")
	return nil
}

func (wp *WorkerPool) Submit(task Task) {
	select {
	case wp.tasks <- task:
		// Task submitted successfully
	default:
		wp.logger.Warn().Msg("Worker pool task queue is full")
		// Try to submit with timeout
		select {
		case wp.tasks <- task:
			// Task submitted after waiting
		case <-time.After(1 * time.Second):
			wp.logger.Error().Msg("Failed to submit task to worker pool (timeout)")
		}
	}
}

func (wp *WorkerPool) worker(id int) {
	defer wp.wg.Done()

	wp.mu.Lock()
	wp.activeWorkers++
	wp.mu.Unlock()

	wp.logger.Debug().Int("worker_id", id).Msg("Worker started")

	for task := range wp.tasks {
		wp.logger.Debug().Int("worker_id", id).Msg("Worker processing task")

		// Update active workers count
		wp.mu.Lock()
		wp.activeWorkers--
		wp.mu.Unlock()

		// Execute task
		func() {
			defer func() {
				if r := recover(); r != nil {
					wp.logger.Error().
						Int("worker_id", id).
						Interface("panic", r).
						Msg("Worker recovered from panic")
				}

				// Update active workers count
				wp.mu.Lock()
				wp.activeWorkers++
				wp.mu.Unlock()
			}()

			task()
		}()
	}

	wp.mu.Lock()
	wp.activeWorkers--
	wp.mu.Unlock()

	wp.logger.Debug().Int("worker_id", id).Msg("Worker stopped")
}

func (wp *WorkerPool) GetActiveWorkers() int {
	wp.mu.RLock()
	defer wp.mu.RUnlock()
	return wp.activeWorkers
}

func (wp *WorkerPool) GetQueueLength() int {
	return len(wp.tasks)
}

func (wp *WorkerPool) GetStats() map[string]interface{} {
	wp.mu.RLock()
	defer wp.mu.RUnlock()

	return map[string]interface{}{
		"active_workers": wp.activeWorkers,
		"max_workers":    wp.maxWorkers,
		"queue_length":   len(wp.tasks),
		"queue_capacity": cap(wp.tasks),
	}
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\worker\queue\handler.go
================================================================================

package queue

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/RubachokBoss/plagiarism-checker/analysis-service/internal/models"
	"github.com/rs/zerolog"
)

type MessageHandler interface {
	HandleWorkCreated(ctx context.Context, event models.WorkCreatedEvent) error
	HandleAnalysisRequest(ctx context.Context, request models.PlagiarismCheckRequest) error
	HandleBatchRequest(ctx context.Context, request models.BatchAnalysisRequest) error
}

type messageHandler struct {
	logger zerolog.Logger
	// Add dependencies here (e.g., services)
}

func NewMessageHandler(logger zerolog.Logger) MessageHandler {
	return &messageHandler{
		logger: logger,
	}
}

func (h *messageHandler) HandleWorkCreated(ctx context.Context, event models.WorkCreatedEvent) error {
	h.logger.Info().
		Str("work_id", event.WorkID).
		Str("file_id", event.FileID).
		Str("assignment_id", event.AssignmentID).
		Msg("Handling work created event")

	// In real implementation, this would trigger analysis
	// For now, just log the event
	return nil
}

func (h *messageHandler) HandleAnalysisRequest(ctx context.Context, request models.PlagiarismCheckRequest) error {
	h.logger.Info().
		Str("work_id", request.WorkID).
		Str("file_id", request.FileID).
		Str("assignment_id", request.AssignmentID).
		Msg("Handling analysis request")

	// In real implementation, this would start analysis
	// For now, just log the request
	return nil
}

func (h *messageHandler) HandleBatchRequest(ctx context.Context, request models.BatchAnalysisRequest) error {
	h.logger.Info().
		Int("work_count", len(request.WorkIDs)).
		Msg("Handling batch analysis request")

	// Process each work in batch
	for _, workID := range request.WorkIDs {
		h.logger.Debug().Str("work_id", workID).Msg("Processing work in batch")
		// In real implementation, process each work
	}

	return nil
}

// ProcessMessage processes incoming RabbitMQ messages
func (h *messageHandler) ProcessMessage(ctx context.Context, msg RabbitMQMessage) error {
	// Parse message based on routing key or message type
	// This is a simplified implementation
	var messageData map[string]interface{}
	if err := json.Unmarshal(msg.Body, &messageData); err != nil {
		return fmt.Errorf("failed to unmarshal message: %w", err)
	}

	// Determine message type
	msgType, ok := messageData["type"].(string)
	if !ok {
		return fmt.Errorf("message type not specified")
	}

	switch msgType {
	case "work.created":
		var event models.WorkCreatedEvent
		if err := json.Unmarshal(msg.Body, &event); err != nil {
			return fmt.Errorf("failed to unmarshal work created event: %w", err)
		}
		return h.HandleWorkCreated(ctx, event)

	case "analysis.request":
		var request models.PlagiarismCheckRequest
		if err := json.Unmarshal(msg.Body, &request); err != nil {
			return fmt.Errorf("failed to unmarshal analysis request: %w", err)
		}
		return h.HandleAnalysisRequest(ctx, request)

	case "batch.request":
		var request models.BatchAnalysisRequest
		if err := json.Unmarshal(msg.Body, &request); err != nil {
			return fmt.Errorf("failed to unmarshal batch request: %w", err)
		}
		return h.HandleBatchRequest(ctx, request)

	default:
		h.logger.Warn().Str("type", msgType).Msg("Unknown message type")
		return nil
	}
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\worker\queue\rabbitmq_consumer.go
================================================================================

package queue

import (
	"context"
	"time"

	"github.com/rabbitmq/amqp091-go"
	"github.com/rs/zerolog"
)

type RabbitMQMessage struct {
	Body      []byte
	Timestamp time.Time
	Ack       func(multiple bool) error
	Nack      func(multiple bool, requeue bool) error
}

type RabbitMQConsumer interface {
	Consume(ctx context.Context) (<-chan RabbitMQMessage, error)
	GetQueueLength() (int, error)
	Close() error
}

type rabbitMQConsumer struct {
	channel     *amqp091.Channel
	queue       string
	consumerTag string
	logger      zerolog.Logger
}

func NewRabbitMQConsumer(channel *amqp091.Channel, queue, consumerTag string, logger zerolog.Logger) RabbitMQConsumer {
	return &rabbitMQConsumer{
		channel:     channel,
		queue:       queue,
		consumerTag: consumerTag,
		logger:      logger,
	}
}

func (c *rabbitMQConsumer) Consume(ctx context.Context) (<-chan RabbitMQMessage, error) {
	// Set prefetch count
	err := c.channel.Qos(
		1,     // prefetch count
		0,     // prefetch size
		false, // global
	)
	if err != nil {
		return nil, err
	}

	// Start consuming
	msgs, err := c.channel.Consume(
		c.queue,       // queue
		c.consumerTag, // consumer
		false,         // auto-ack
		false,         // exclusive
		false,         // no-local
		false,         // no-wait
		nil,           // args
	)
	if err != nil {
		return nil, err
	}

	// Convert to our message type
	output := make(chan RabbitMQMessage)

	go func() {
		defer close(output)

		for {
			select {
			case <-ctx.Done():
				c.logger.Info().Msg("Stopping RabbitMQ consumer")
				return
			case msg, ok := <-msgs:
				if !ok {
					c.logger.Warn().Msg("RabbitMQ message channel closed")
					return
				}

				// Create our message wrapper
				rabbitMsg := RabbitMQMessage{
					Body:      msg.Body,
					Timestamp: msg.Timestamp,
					Ack:       msg.Ack,
					Nack:      msg.Nack,
				}

				// Send to output channel
				select {
				case output <- rabbitMsg:
					// Message sent successfully
				case <-ctx.Done():
					// Context cancelled, nack the message
					msg.Nack(false, true)
					return
				}
			}
		}
	}()

	c.logger.Info().
		Str("queue", c.queue).
		Str("consumer_tag", c.consumerTag).
		Msg("RabbitMQ consumer started")

	return output, nil
}

func (c *rabbitMQConsumer) GetQueueLength() (int, error) {
	queue, err := c.channel.QueueDeclarePassive(
		c.queue, // name
		true,    // durable
		false,   // delete when unused
		false,   // exclusive
		false,   // no-wait
		nil,     // arguments
	)
	if err != nil {
		return 0, err
	}

	return queue.Messages, nil
}

func (c *rabbitMQConsumer) Close() error {
	if c.channel != nil {
		// Cancel consumer
		if err := c.channel.Cancel(c.consumerTag, false); err != nil {
			c.logger.Error().Err(err).Msg("Failed to cancel RabbitMQ consumer")
		}

		// Channel will be closed by parent
	}

	c.logger.Info().Msg("RabbitMQ consumer closed")
	return nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\internal\worker\queue\rabbitmq_publisher.go
================================================================================

package queue

import (
	"context"
	"time"

	"github.com/rabbitmq/amqp091-go"
	"github.com/rs/zerolog"
)

type RabbitMQPublisher interface {
	Publish(ctx context.Context, exchange, routingKey string, body []byte) error
	PublishWithDelay(ctx context.Context, exchange, routingKey string, body []byte, delay time.Duration) error
	Close() error
}

type rabbitMQPublisher struct {
	channel *amqp091.Channel
	logger  zerolog.Logger
}

func NewRabbitMQPublisher(channel *amqp091.Channel, logger zerolog.Logger) RabbitMQPublisher {
	return &rabbitMQPublisher{
		channel: channel,
		logger:  logger,
	}
}

func (p *rabbitMQPublisher) Publish(ctx context.Context, exchange, routingKey string, body []byte) error {
	// Set up context with timeout
	publishCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return p.channel.PublishWithContext(
		publishCtx,
		exchange,   // exchange
		routingKey, // routing key
		false,      // mandatory
		false,      // immediate
		amqp091.Publishing{
			ContentType:  "application/json",
			Body:         body,
			DeliveryMode: amqp091.Persistent,
			Timestamp:    time.Now(),
		},
	)
}

func (p *rabbitMQPublisher) PublishWithDelay(ctx context.Context, exchange, routingKey string, body []byte, delay time.Duration) error {
	// For delayed messages, we need to use delayed message exchange plugin
	// This is a simplified implementation

	// Set up context with timeout
	publishCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Add delay header if supported
	headers := amqp091.Table{}
	if delay > 0 {
		headers["x-delay"] = int32(delay.Milliseconds())
	}

	return p.channel.PublishWithContext(
		publishCtx,
		exchange,   // exchange
		routingKey, // routing key
		false,      // mandatory
		false,      // immediate
		amqp091.Publishing{
			ContentType:  "application/json",
			Body:         body,
			DeliveryMode: amqp091.Persistent,
			Timestamp:    time.Now(),
			Headers:      headers,
		},
	)
}

func (p *rabbitMQPublisher) Close() error {
	// Channel will be closed by parent
	p.logger.Info().Msg("RabbitMQ publisher closed")
	return nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\migrations\001_create_reports.down.sql
================================================================================

-- РЈРґР°Р»РµРЅРёРµ С‚СЂРёРіРіРµСЂРѕРІ
DROP TRIGGER IF EXISTS update_reports_updated_at ON reports;
DROP TRIGGER IF EXISTS update_assignment_stats_updated_at ON assignment_stats;
DROP TRIGGER IF EXISTS update_student_stats_updated_at ON student_stats;
DROP TRIGGER IF EXISTS update_assignment_stats_trigger ON reports;
DROP TRIGGER IF EXISTS update_student_stats_trigger ON reports;

-- РЈРґР°Р»РµРЅРёРµ С„СѓРЅРєС†РёР№
DROP FUNCTION IF EXISTS update_updated_at_column();
DROP FUNCTION IF EXISTS update_assignment_stats();
DROP FUNCTION IF EXISTS update_student_stats();

-- РЈРґР°Р»РµРЅРёРµ С‚Р°Р±Р»РёС† РІ РїСЂР°РІРёР»СЊРЅРѕРј РїРѕСЂСЏРґРєРµ
DROP TABLE IF EXISTS analysis_queue;
DROP TABLE IF EXISTS student_stats;
DROP TABLE IF EXISTS assignment_stats;
DROP TABLE IF EXISTS reports;



================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\migrations\001_create_reports.up.sql
================================================================================

-- РЎРѕР·РґР°РЅРёРµ С‚Р°Р±Р»РёС†С‹ РѕС‚С‡РµС‚РѕРІ
CREATE TABLE IF NOT EXISTS reports (
                                       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    work_id UUID NOT NULL,
    file_id VARCHAR(255) NOT NULL,
    assignment_id UUID NOT NULL,
    student_id UUID NOT NULL,

    -- РЎС‚Р°С‚СѓСЃ Р°РЅР°Р»РёР·Р°
    status VARCHAR(50) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'failed')),

    -- Р РµР·СѓР»СЊС‚Р°С‚С‹ РїСЂРѕРІРµСЂРєРё РЅР° РїР»Р°РіРёР°С‚
    plagiarism_flag BOOLEAN DEFAULT FALSE,
    original_work_id UUID,
    match_percentage INTEGER DEFAULT 0,
    CHECK (match_percentage >= 0 AND match_percentage <= 100),

    -- РҐСЌС€Рё С„Р°Р№Р»РѕРІ
    file_hash VARCHAR(64),
    compared_hashes TEXT[], -- РњР°СЃСЃРёРІ С…СЌС€РµР№ СЃ РєРѕС‚РѕСЂС‹РјРё СЃСЂР°РІРЅРёРІР°Р»Рё

-- Р”РµС‚Р°Р»Рё Р°РЅР°Р»РёР·Р°
    details JSONB DEFAULT '{}',

    -- РњРµС‚СЂРёРєРё РїСЂРѕРёР·РІРѕРґРёС‚РµР»СЊРЅРѕСЃС‚Рё
    processing_time_ms INTEGER,
    compared_files_count INTEGER DEFAULT 0,

    -- Р’СЂРµРјРµРЅРЅС‹Рµ РјРµС‚РєРё
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

                             -- РРЅРґРµРєСЃС‹
                             UNIQUE(work_id),
    INDEX idx_reports_work_id ON reports(work_id),
    INDEX idx_reports_assignment_id ON reports(assignment_id),
    INDEX idx_reports_student_id ON reports(student_id),
    INDEX idx_reports_status ON reports(status),
    INDEX idx_reports_plagiarism_flag ON reports(plagiarism_flag),
    INDEX idx_reports_created_at ON reports(created_at),
    INDEX idx_reports_file_hash ON reports(file_hash)
    );

-- РўР°Р±Р»РёС†Р° РґР»СЏ СЃС‚Р°С‚РёСЃС‚РёРєРё РїРѕ Р·Р°РґР°РЅРёСЏРј
CREATE TABLE IF NOT EXISTS assignment_stats (
                                                assignment_id UUID PRIMARY KEY,
                                                total_works INTEGER DEFAULT 0,
                                                analyzed_works INTEGER DEFAULT 0,
                                                plagiarized_works INTEGER DEFAULT 0,
                                                avg_match_percentage DECIMAL(5,2) DEFAULT 0,
    last_analyzed_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                             );

-- РўР°Р±Р»РёС†Р° РґР»СЏ СЃС‚Р°С‚РёСЃС‚РёРєРё РїРѕ СЃС‚СѓРґРµРЅС‚Р°Рј
CREATE TABLE IF NOT EXISTS student_stats (
                                             student_id UUID PRIMARY KEY,
                                             total_works INTEGER DEFAULT 0,
                                             analyzed_works INTEGER DEFAULT 0,
                                             plagiarized_works INTEGER DEFAULT 0,
                                             avg_match_percentage DECIMAL(5,2) DEFAULT 0,
    last_analyzed_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                             );

-- РўР°Р±Р»РёС†Р° РґР»СЏ РѕС‡РµСЂРµРґРё Р°РЅР°Р»РёР·Р° (РµСЃР»Рё РЅСѓР¶РЅРѕ СЃРѕС…СЂР°РЅСЏС‚СЊ Р·Р°РґР°С‡Рё)
CREATE TABLE IF NOT EXISTS analysis_queue (
                                              id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    work_id UUID NOT NULL,
    file_id VARCHAR(255) NOT NULL,
    assignment_id UUID NOT NULL,
    student_id UUID NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    priority INTEGER DEFAULT 0,
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,

                               INDEX idx_analysis_queue_status ON analysis_queue(status),
    INDEX idx_analysis_queue_priority ON analysis_queue(priority),
    INDEX idx_analysis_queue_scheduled_at ON analysis_queue(scheduled_at)
    );

-- РўСЂРёРіРіРµСЂ РґР»СЏ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРіРѕ РѕР±РЅРѕРІР»РµРЅРёСЏ updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_reports_updated_at
    BEFORE UPDATE ON reports
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_assignment_stats_updated_at
    BEFORE UPDATE ON assignment_stats
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_student_stats_updated_at
    BEFORE UPDATE ON student_stats
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Р¤СѓРЅРєС†РёСЏ РґР»СЏ РѕР±РЅРѕРІР»РµРЅРёСЏ СЃС‚Р°С‚РёСЃС‚РёРєРё Р·Р°РґР°РЅРёР№
CREATE OR REPLACE FUNCTION update_assignment_stats()
RETURNS TRIGGER AS $$
BEGIN
    -- РћР±РЅРѕРІР»СЏРµРј СЃС‚Р°С‚РёСЃС‚РёРєСѓ Р·Р°РґР°РЅРёСЏ
INSERT INTO assignment_stats (
    assignment_id,
    total_works,
    analyzed_works,
    plagiarized_works,
    avg_match_percentage,
    last_analyzed_at,
    updated_at
)
SELECT
    NEW.assignment_id,
    COUNT(*) as total_works,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as analyzed_works,
    COUNT(CASE WHEN plagiarism_flag = TRUE THEN 1 END) as plagiarized_works,
    COALESCE(AVG(CASE WHEN status = 'completed' THEN match_percentage END), 0) as avg_match_percentage,
    MAX(completed_at) as last_analyzed_at,
    CURRENT_TIMESTAMP
FROM reports
WHERE assignment_id = NEW.assignment_id
    ON CONFLICT (assignment_id) DO UPDATE SET
    total_works = EXCLUDED.total_works,
                                       analyzed_works = EXCLUDED.analyzed_works,
                                       plagiarized_works = EXCLUDED.plagiarized_works,
                                       avg_match_percentage = EXCLUDED.avg_match_percentage,
                                       last_analyzed_at = EXCLUDED.last_analyzed_at,
                                       updated_at = EXCLUDED.updated_at;

RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_assignment_stats_trigger
    AFTER INSERT OR UPDATE ON reports
                        FOR EACH ROW EXECUTE FUNCTION update_assignment_stats();

-- Р¤СѓРЅРєС†РёСЏ РґР»СЏ РѕР±РЅРѕРІР»РµРЅРёСЏ СЃС‚Р°С‚РёСЃС‚РёРєРё СЃС‚СѓРґРµРЅС‚РѕРІ
CREATE OR REPLACE FUNCTION update_student_stats()
RETURNS TRIGGER AS $$
BEGIN
    -- РћР±РЅРѕРІР»СЏРµРј СЃС‚Р°С‚РёСЃС‚РёРєСѓ СЃС‚СѓРґРµРЅС‚Р°
INSERT INTO student_stats (
    student_id,
    total_works,
    analyzed_works,
    plagiarized_works,
    avg_match_percentage,
    last_analyzed_at,
    updated_at
)
SELECT
    NEW.student_id,
    COUNT(*) as total_works,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as analyzed_works,
    COUNT(CASE WHEN plagiarism_flag = TRUE THEN 1 END) as plagiarized_works,
    COALESCE(AVG(CASE WHEN status = 'completed' THEN match_percentage END), 0) as avg_match_percentage,
    MAX(completed_at) as last_analyzed_at,
    CURRENT_TIMESTAMP
FROM reports
WHERE student_id = NEW.student_id
    ON CONFLICT (student_id) DO UPDATE SET
    total_works = EXCLUDED.total_works,
                                    analyzed_works = EXCLUDED.analyzed_works,
                                    plagiarized_works = EXCLUDED.plagiarized_works,
                                    avg_match_percentage = EXCLUDED.avg_match_percentage,
                                    last_analyzed_at = EXCLUDED.last_analyzed_at,
                                    updated_at = EXCLUDED.updated_at;

RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_student_stats_trigger
    AFTER INSERT OR UPDATE ON reports
                        FOR EACH ROW EXECUTE FUNCTION update_student_stats();



================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\pkg\hash\hash.go
================================================================================

package hash

import (
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"hash"
	"io"
	"os"
)

// HashAlgorithm С‚РёРї РґР»СЏ Р°Р»РіРѕСЂРёС‚РјРѕРІ С…СЌС€РёСЂРѕРІР°РЅРёСЏ
type HashAlgorithm string

const (
	MD5    HashAlgorithm = "md5"
	SHA1   HashAlgorithm = "sha1"
	SHA256 HashAlgorithm = "sha256"
	SHA512 HashAlgorithm = "sha512"
)

// FileHashResult СЃРѕРґРµСЂР¶РёС‚ СЂРµР·СѓР»СЊС‚Р°С‚ С…СЌС€РёСЂРѕРІР°РЅРёСЏ С„Р°Р№Р»Р°
type FileHashResult struct {
	Algorithm HashAlgorithm
	Hash      string
	FileSize  int64
	FileName  string
}

// Hasher РёРЅС‚РµСЂС„РµР№СЃ РґР»СЏ С…СЌС€РёСЂРѕРІР°РЅРёСЏ
type Hasher interface {
	Calculate(data []byte) (string, error)
	CalculateFile(filePath string) (*FileHashResult, error)
	CalculateReader(reader io.Reader) (string, error)
	Verify(data []byte, expectedHash string) (bool, error)
}

// FileHasher СЂРµР°Р»РёР·Р°С†РёСЏ С…СЌС€РёСЂРѕРІР°РЅРёСЏ С„Р°Р№Р»РѕРІ
type FileHasher struct {
	algorithm HashAlgorithm
}

// NewFileHasher СЃРѕР·РґР°РµС‚ РЅРѕРІС‹Р№ FileHasher
func NewFileHasher(algorithm HashAlgorithm) *FileHasher {
	return &FileHasher{
		algorithm: algorithm,
	}
}

// Calculate РІС‹С‡РёСЃР»СЏРµС‚ С…СЌС€ РґР»СЏ РґР°РЅРЅС‹С…
func (h *FileHasher) Calculate(data []byte) (string, error) {
	hasher, err := h.getHasher()
	if err != nil {
		return "", err
	}

	hasher.Write(data)
	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// CalculateFile РІС‹С‡РёСЃР»СЏРµС‚ С…СЌС€ РґР»СЏ С„Р°Р№Р»Р°
func (h *FileHasher) CalculateFile(filePath string) (*FileHashResult, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("failed to get file stats: %w", err)
	}

	hashStr, err := h.CalculateReader(file)
	if err != nil {
		return nil, err
	}

	return &FileHashResult{
		Algorithm: h.algorithm,
		Hash:      hashStr,
		FileSize:  stat.Size(),
		FileName:  stat.Name(),
	}, nil
}

// CalculateReader РІС‹С‡РёСЃР»СЏРµС‚ С…СЌС€ РґР»СЏ reader
func (h *FileHasher) CalculateReader(reader io.Reader) (string, error) {
	hasher, err := h.getHasher()
	if err != nil {
		return "", err
	}

	if _, err := io.Copy(hasher, reader); err != nil {
		return "", fmt.Errorf("failed to read data: %w", err)
	}

	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// Verify РїСЂРѕРІРµСЂСЏРµС‚ С…СЌС€ РґР°РЅРЅС‹С…
func (h *FileHasher) Verify(data []byte, expectedHash string) (bool, error) {
	calculatedHash, err := h.Calculate(data)
	if err != nil {
		return false, err
	}

	return calculatedHash == expectedHash, nil
}

// getHasher РІРѕР·РІСЂР°С‰Р°РµС‚ СЃРѕРѕС‚РІРµС‚СЃС‚РІСѓСЋС‰РёР№ С…СЌС€РµСЂ
func (h *FileHasher) getHasher() (hash.Hash, error) {
	switch h.algorithm {
	case MD5:
		return md5.New(), nil
	case SHA1:
		return sha1.New(), nil
	case SHA256:
		return sha256.New(), nil
	case SHA512:
		return sha512.New(), nil
	default:
		return nil, fmt.Errorf("unsupported hash algorithm: %s", h.algorithm)
	}
}

// CompareFiles СЃСЂР°РІРЅРёРІР°РµС‚ РґРІР° С„Р°Р№Р»Р° РїРѕ С…СЌС€Сѓ
func CompareFiles(file1, file2 string, algorithm HashAlgorithm) (bool, error) {
	hasher := NewFileHasher(algorithm)

	hash1, err := hasher.CalculateFile(file1)
	if err != nil {
		return false, err
	}

	hash2, err := hasher.CalculateFile(file2)
	if err != nil {
		return false, err
	}

	return hash1.Hash == hash2.Hash, nil
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\pkg\logger\logger.go
================================================================================

package logger

import (
	"os"
	"time"

	"github.com/rs/zerolog"
)

func New() zerolog.Logger {
	// РќР°СЃС‚СЂРѕР№РєР° output
	output := zerolog.ConsoleWriter{
		Out:        os.Stdout,
		TimeFormat: time.RFC3339,
		NoColor:    false,
	}

	// РЎРѕР·РґР°РЅРёРµ Р»РѕРіРіРµСЂР°
	logger := zerolog.New(output).
		With().
		Timestamp().
		Caller().
		Logger()

	// РЈСЂРѕРІРµРЅСЊ Р»РѕРіРёСЂРѕРІР°РЅРёСЏ
	logger = logger.Level(zerolog.InfoLevel)

	return logger
}

func NewWithConfig(level string, pretty, noColor bool) zerolog.Logger {
	var log zerolog.Logger

	if pretty {
		output := zerolog.ConsoleWriter{
			Out:        os.Stdout,
			TimeFormat: time.RFC3339,
			NoColor:    noColor,
		}
		log = zerolog.New(output).With().Timestamp().Logger()
	} else {
		log = zerolog.New(os.Stdout).With().Timestamp().Logger()
	}

	// РЈСЃС‚Р°РЅРѕРІРєР° СѓСЂРѕРІРЅСЏ Р»РѕРіРёСЂРѕРІР°РЅРёСЏ
	switch level {
	case "debug":
		log = log.Level(zerolog.DebugLevel)
	case "info":
		log = log.Level(zerolog.InfoLevel)
	case "warn":
		log = log.Level(zerolog.WarnLevel)
	case "error":
		log = log.Level(zerolog.ErrorLevel)
	default:
		log = log.Level(zerolog.InfoLevel)
	}

	return log
}




================================================================================
ФАЙЛ: C:\Users\water\GolandProjects\plagiarism-checker\analysis-service\pkg\utils\utils.go
================================================================================

package utils

import (
	"crypto/md5"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
)

// WriteJSON Р·Р°РїРёСЃС‹РІР°РµС‚ JSON РѕС‚РІРµС‚
func WriteJSON(w http.ResponseWriter, status int, data interface{}) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	return json.NewEncoder(w).Encode(data)
}

// ReadJSON С‡РёС‚Р°РµС‚ JSON РёР· Р·Р°РїСЂРѕСЃР°
func ReadJSON(r *http.Request, dst interface{}) error {
	decoder := json.NewDecoder(r.Body)
	decoder.DisallowUnknownFields()
	return decoder.Decode(dst)
}

// ErrorResponse СЃРѕР·РґР°РµС‚ СЃС‚Р°РЅРґР°СЂС‚РёР·РёСЂРѕРІР°РЅРЅС‹Р№ РѕС‚РІРµС‚ РѕР± РѕС€РёР±РєРµ
func ErrorResponse(w http.ResponseWriter, status int, message string) {
	WriteJSON(w, status, map[string]string{
		"error": message,
	})
}

// SuccessResponse СЃРѕР·РґР°РµС‚ СЃС‚Р°РЅРґР°СЂС‚РёР·РёСЂРѕРІР°РЅРЅС‹Р№ СѓСЃРїРµС€РЅС‹Р№ РѕС‚РІРµС‚
func SuccessResponse(w http.ResponseWriter, data interface{}) {
	response := map[string]interface{}{
		"success": true,
		"data":    data,
	}
	WriteJSON(w, http.StatusOK, response)
}

// GenerateUUID РіРµРЅРµСЂРёСЂСѓРµС‚ UUID СЃС‚СЂРѕРєСѓ
func GenerateUUID() string {
	return uuid.New().String()
}

// CalculateHash РІС‹С‡РёСЃР»СЏРµС‚ С…СЌС€ РґР°РЅРЅС‹С…
func CalculateHash(data []byte, algorithm string) (string, error) {
	switch algorithm {
	case "sha256":
		hash := sha256.Sum256(data)
		return hex.EncodeToString(hash[:]), nil
	case "md5":
		hash := md5.Sum(data)
		return hex.EncodeToString(hash[:]), nil
	default:
		return "", fmt.Errorf("unsupported hash algorithm: %s", algorithm)
	}
}

// ValidateUUID РїСЂРѕРІРµСЂСЏРµС‚, СЏРІР»СЏРµС‚СЃСЏ Р»Рё СЃС‚СЂРѕРєР° РІР°Р»РёРґРЅС‹Рј UUID
func ValidateUUID(u string) bool {
	_, err := uuid.Parse(u)
	return err == nil
}



